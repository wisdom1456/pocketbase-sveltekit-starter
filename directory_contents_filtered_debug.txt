Path: D:\Modible\Software\pocketbase-sveltekit-starter\.dockerignore
Contents:
# flyctl launch added from .gitignore
**\.cache
**\.local
**\.npm
**\.env
**\.ash_history
docker-compose.override.yml

# flyctl launch added from pb\.gitignore
pb\.cache
pb\pocketbase
pb\pocketbase*.zip
pb\pb_data
pb\tmp
# pb\pb_public

# flyctl launch added from sk\.gitignore
sk\**\.DS_Store
sk\**\node_modules
sk\playwright-report
# sk\build
sk\.svelte-kit
sk\package
sk\**\.env
sk\**\.env.*
!sk\**\.env.example

# flyctl launch added from sk\node_modules\.pnpm\digest-fetch@1.3.0\node_modules\digest-fetch\.gitignore
!sk\node_modules\.pnpm\digest-fetch@1.3.0\node_modules\digest-fetch\**\.gitignore
sk\node_modules\.pnpm\digest-fetch@1.3.0\node_modules\digest-fetch\**\node_modules
sk\node_modules\.pnpm\digest-fetch@1.3.0\node_modules\digest-fetch\**\packing


# flyctl launch added from sk\node_modules\.pnpm\minipass-sized@1.0.3\node_modules\minipass-sized\.gitignore
# ignore most things, include some others
sk\node_modules\.pnpm\minipass-sized@1.0.3\node_modules\minipass-sized\*
sk\node_modules\.pnpm\minipass-sized@1.0.3\node_modules\minipass-sized\.*

!sk\node_modules\.pnpm\minipass-sized@1.0.3\node_modules\minipass-sized\**\bin
!sk\node_modules\.pnpm\minipass-sized@1.0.3\node_modules\minipass-sized\**\lib
!sk\node_modules\.pnpm\minipass-sized@1.0.3\node_modules\minipass-sized\**\docs
!sk\node_modules\.pnpm\minipass-sized@1.0.3\node_modules\minipass-sized\**\package.json
!sk\node_modules\.pnpm\minipass-sized@1.0.3\node_modules\minipass-sized\**\package-lock.json
!sk\node_modules\.pnpm\minipass-sized@1.0.3\node_modules\minipass-sized\**\README.md
!sk\node_modules\.pnpm\minipass-sized@1.0.3\node_modules\minipass-sized\**\CONTRIBUTING.md
!sk\node_modules\.pnpm\minipass-sized@1.0.3\node_modules\minipass-sized\**\LICENSE
!sk\node_modules\.pnpm\minipass-sized@1.0.3\node_modules\minipass-sized\**\CHANGELOG.md
!sk\node_modules\.pnpm\minipass-sized@1.0.3\node_modules\minipass-sized\**\example
!sk\node_modules\.pnpm\minipass-sized@1.0.3\node_modules\minipass-sized\**\scripts
!sk\node_modules\.pnpm\minipass-sized@1.0.3\node_modules\minipass-sized\**\tap-snapshots
!sk\node_modules\.pnpm\minipass-sized@1.0.3\node_modules\minipass-sized\**\test
!sk\node_modules\.pnpm\minipass-sized@1.0.3\node_modules\minipass-sized\**\.travis.yml
!sk\node_modules\.pnpm\minipass-sized@1.0.3\node_modules\minipass-sized\**\.gitignore
!sk\node_modules\.pnpm\minipass-sized@1.0.3\node_modules\minipass-sized\**\.gitattributes
!sk\node_modules\.pnpm\minipass-sized@1.0.3\node_modules\minipass-sized\**\coverage-map.js
!sk\node_modules\.pnpm\minipass-sized@1.0.3\node_modules\minipass-sized\**\index.js

# flyctl launch added from sk\node_modules\.pnpm\tailwindcss@3.4.1\node_modules\tailwindcss\stubs\.gitignore
!sk\node_modules\.pnpm\tailwindcss@3.4.1\node_modules\tailwindcss\stubs\**\*
fly.toml


Path: D:\Modible\Software\pocketbase-sveltekit-starter\click on a bullet point and generat.txt
Contents:
click on a bullet point and generate a new article
generate a tree based on the article tags and titles

-------
Remember

One Sentence.
->
Interpret users intent
-> respond with 3 different interpretations of the users entry
User selects an option
Blog is generated based on user selection.

-------
Create

1) User can view a blog a click bullet points to generate new articles
2) User can enter a new statement
->
Interpret users intent
-> respond with 3 different interpretations of the users entry
User selects an option
Blog is generated based on user selection.
3) User can ask the AI to generate 3 new concepts/ideas based on the article
-> User can choose which one the generate a new article

User can enter notes about the blog

-------
Inspire

User can view a tree of the blogs.
User can select tags to filter blogs
User can add multiple blogs, and generate a new blog based on them

This will have a left pane and a main window

The left pane will have the tree

you can search the tags in a search menu and it will change the main view to the returned blogs

----------------

Project Overview: AI Journal Webapp
Menu System and Navigation:
A fixed, globally accessible menu provides seamless navigation across the app, featuring links to all main pages: Home (Create Page), Remember, Inspire, Explore, Reflect, and any other utility pages like Settings or Help.
The menu integrates user-centric features like quick access to recent documents, a search bar for content within the app, and user profile settings.
Pages and Functionalities:
Home (Create Page)

Functionality: Central hub for content creation, featuring a minimalist design with a versatile input box for text, links, or questions. The system dynamically responds based on the type of input.
Data Interactions: Inputs are processed to generate content, parse links, or provide answers. User-generated content is saved and can be linked or referenced in other areas of the app.
Prototype Code: Function to process user input and determine action.
python
Copy code
def process_input(user_input):
    # Pseudocode to categorize input type
    if is_link(user_input):
        return parse_link(user_input)
    elif is_question(user_input):
        return generate_answer(user_input)
    else:
        return generate_content(user_input)
Remember Page

Functionality: Allows users to input a thought and receive multiple interpretations or expansions. Users select one to develop into a full article.
Data Interactions: Inputs and selections are stored for user history and can influence future content recommendations or interpretations.
Prototype Code: Function to interpret user input.
python
Copy code
def interpret_thought(user_thought):
    # Generate interpretations (simplified)
    interpretations = generate_interpretations(user_thought)
    return interpretations
Inspire Page

Functionality: Visual and interactive exploration of blog connections and content synthesis based on selected blogs or tags.
Data Interactions: Uses tag and content metadata to organize and display connections. User selections for synthesis are processed to create new, combined content.
Prototype Code: Function to synthesize content from selections.
python
Copy code
def synthesize_content(selected_blogs):
    # Combine content from selected blogs
    combined_content = combine(selected_blogs)
    return combined_content
Explore Page

Functionality: Discovery of AI-curated content and random content suggestions. Includes personalized recommendations based on user activity.
Data Interactions: Tracks user interactions to refine recommendations. External data (e.g., trending topics) may be incorporated for curation.
Prototype Code: Function for personalized recommendations.
python
Copy code
def get_recommendations(user_profile):
    # Fetch recommendations based on user profile
    recommendations = fetch_curated_content(user_profile)
    return recommendations
Reflect Page

Functionality: Private space for journaling and personal reflection with prompts based on user activity or significant dates. Offers growth tracking and insights.
Data Interactions: Interacts with user-generated content and activity logs to provide personalized prompts and track personal growth metrics.
Prototype Code: Function to generate reflection prompts.
python
Copy code
def generate_reflection_prompt(user_activity):
    # Generate prompts based on user activity
    prompt = create_prompt(user_activity)
    return prompt
Interconnections and Data Flow:
User Profile and Activity Tracking: Central to personalizing experiences across Explore, Reflect, and personalized content recommendations. User data, including preferences, content interactions, and history, is stored securely and used to tailor app interactions.
Content Creation and Sharing: Content generated or curated by the user in the Create and Remember pages can be shared, tagged, and integrated into the Inspire and Explore pages for broader community engagement.
External Data Integration: For the Explore page and content parsing features (e.g., summarizing shared links), external APIs or scraping techniques may be employed, adhering to privacy and copyright laws.
Implementation Considerations:
Security and Privacy: Ensure user data is handled securely, with clear privacy policies and compliance with regulations (e.g., GDPR).
Scalability: Design backend systems to handle increasing amounts of user data and content efficiently.
User Experience: Focus on intuitive design and seamless navigation across pages, ensuring responsiveness and accessibility.

Path: D:\Modible\Software\pocketbase-sveltekit-starter\Dockerfile
Contents:
FROM golang:1.22-alpine AS builder
WORKDIR /build
COPY pb/go.mod pb/go.sum ./
RUN go mod download
COPY pb/main.go ./
COPY pb/hooks ./hooks
RUN apk --no-cache add upx make git gcc libtool musl-dev ca-certificates dumb-init \
  && go mod tidy \
  && CGO_ENABLED=0 go build \
  && upx pocketbase

FROM alpine
WORKDIR /app/pb
COPY --from=builder /build/pocketbase /app/pb/pocketbase
COPY pb/pb_migrations ./pb_migrations
COPY ./sk/pnpm-lock.yaml ./sk/package.json ./
COPY ./sk/build ./pb_public
COPY pb/data/email_templates ./data/email_templates

ENTRYPOINT ["/app/pb/pocketbase", "serve", "--http", "0.0.0.0:8090", "--publicDir", "./sk/build"]

Path: D:\Modible\Software\pocketbase-sveltekit-starter\fly.toml
Contents:
# fly.toml app configuration file generated for pocketbase-sveltekit-starter-restless-river-3259 on 2024-04-10T13:19:58-05:00
#
# See https://fly.io/docs/reference/configuration/ for information about how to use this file.
#

app = 'pocketbase-sveltekit-starter-restless-river-3259'
primary_region = 'atl'

[build]
  dockerfile = 'Dockerfile'

[http_service]
  internal_port = 8090
  force_https = true
  auto_stop_machines = false
  auto_start_machines = false
  min_machines_running = 1
  processes = ['app']

[[vm]]
  memory = '1gb'
  cpu_kind = 'shared'
  cpus = 1


Path: D:\Modible\Software\pocketbase-sveltekit-starter\LICENSE.md
Contents:
The MIT License (MIT)
Copyright (c) 2022 - present, Jitesh Doshi

Permission is hereby granted, free of charge, to any person obtaining a copy of this software
and associated documentation files (the "Software"), to deal in the Software without restriction,
including without limitation the rights to use, copy, modify, merge, publish, distribute,
sublicense, and/or sell copies of the Software, and to permit persons to whom the Software
is furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all copies or
substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING
BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.


Path: D:\Modible\Software\pocketbase-sveltekit-starter\Procfile
Contents:
web: ./pb/pocketbase serve --http 0.0.0.0:$PORT

Path: D:\Modible\Software\pocketbase-sveltekit-starter\README.md
Contents:
# PocketBase / SvelteKit Starter App

Use this app as a starting point for your own _customized_
[PocketBase](https://github.com/pocketbase/pocketbase) backend
with [SvelteKit](https://kit.svelte.dev) frontend.
This is a high-performance frontend+backend combination since frontend
is static and backend is a single compiled Golang binary (JAMstack baby!).

- SvelteKit frontend is fully static, client-side only so that here is no need
  for NodeJS at runtime. It is generated using [`adapter-static`](https://github.com/sveltejs/kit/tree/master/packages/adapter-static) and `ssr` is OFF.
- PocketBase provides complete (and _fast_) backend including:
  - databse (SQLite)
  - CRUD API for database
  - realtime subscriptions for LIVE data (server push to browser)
  - Authentication and Authorization (email + social login/oauth2)
  - file storage (local filesystem or S3)
  - hooks and API endpoints implemented in JavaScript ([goja](https://github.com/dop251/goja))
- PocketBase can be downloaded as binary. But if you want to extend it with
  custom Golang code then code is included to compile it locally with
  extensions such as custom endpoints (e.g. `/api/hello`) and database event
  hooks (e.g. executing Go handler functions when a database row is created)
- It is now also possible to [extend the backend with JavaScript](https://pocketbase.io/docs/js-overview/).
  See the example [main.pb.ts](./pb/pb_hooks/main.pb.ts).
- A full live development setup is included
  - Hot Module Reloading (HMR) of your frontend app when you edit Svelte code (including proxying requests to the PocketBase backend via `vite`)
  - Hot reloading (restarting) of the PocketBase server using `modd` when you edit Go code
  - Hot reloading (restarting) of the PocketBase server when JS code is changed in `./pb/pb_hooks`

To understand the backend, see [./pb/README.md](./pb/README.md) ("pb" == PocketBase)
To understand the frontend, see [./sk/README.md](./sk/README.md) ("sk" == SvelteKit)

Read those README files before proceeding.

# Setup

Follow these steps CAREFULLY, or else it won't work. Also read the README files referred above before proceeding.

1. If using Docker then copy `.env.example` to `.env` and then edit it to match your environment. And then just run `docker compose up -d`. Without Docker, see below ...
2. Setup the backend in accordance with [./pb/README.md](./pb/README.md)
3. Setup the frontend in accordance with [./sk/README.md](./sk/README.md)

# Developing

After you've done the setup in the above two README files, run
the backend and the frontend in dev mode (from `sk` directory).

```bash
# start the backend
npm run dev:backend
# and then start the frontend ...
npm run dev
```

Now visit http://localhost:5173 (sk) or http://localhost:8090 (pb)

Now making changes in the Svelte code (frontend) or Go code (backend) will show
results (almost) immediately.

# Usage

To use the app as a user / tester ...

- visit the frontend URL (e.g. http://localhost:5173)
- Navigate around. The Home page is not very interesting.
- The `hello` page shows and example of frontend calling a custom backend API implemented in Go.
- The `posts` page shows all existing posts. If that page is empty, then you might want to create some posts. You must be logged in to be able to create posts.
- Into the `Login` form, you can enter an existing username/password, or check the `register` checkbox to create a new account (it registers the user and log in immediately).

The above are just some sample features. Now go ahead and implement all kinds of new features.

- Create new collections.
- Create new pages that manipulate the above collections.

# Building

See the build process details in the README files for backend and frontend.

# Configurable Hooks

Please read about the "hooks" system in [./pb/README.md](./pb/README.md)
It is a very easy and powerful way to extend your application with minimal
configuration and perhaps no code.

# Feedback

Please provide feedback by
[opening an issue](https://github.com/spinspire/pocketbase-sveltekit-starter/issues/new)
or
[starting a discussion](https://github.com/spinspire/pocketbase-sveltekit-starter/discussions).


Path: D:\Modible\Software\pocketbase-sveltekit-starter\runit.bat
Contents:
@echo off
setlocal

REM Navigate to the PocketBase directory and build the project
cd pb
call go build
start cmd /k "pocketbase serve"

REM Navigate to the SvelteKit directory and start the dev server
cd ../sk
start cmd /k "pnpm run dev"

endlocal


Path: D:\Modible\Software\pocketbase-sveltekit-starter\textGen.py
Contents:

import os
import fnmatch

def is_excluded(file_path, exclude_patterns):
    for pattern in exclude_patterns:
        if fnmatch.fnmatch(file_path, pattern):
            print(f"Excluded by pattern {pattern}: {file_path}")
            return True
    return False

def is_binary(file_path):
    try:
        with open(file_path, 'rb') as file:
            if b'\0' in file.read(1024):
                print(f"Identified as binary: {file_path}")
                return True
    except Exception as e:
        print(f"Error checking if binary {file_path}: {e}")
    return False

def generate_tree_view(start_dir, tree, prefix=''):
    tree_view = ''
    for index, (path, sub_tree) in enumerate(tree.items()):
        connector = "└── " if index == len(tree) - 1 else "├── "
        tree_view += f"{prefix}{connector}{os.path.basename(path)}\n"
        if isinstance(sub_tree, dict):  # If the item is a directory
            extension = "    " if index == len(tree) - 1 else "│   "
            tree_view += generate_tree_view(path, sub_tree, prefix=prefix + extension)
    return tree_view

def parse_directory_to_file(output_file_name):
    start_dir = os.getcwd()
    output_file_path = os.path.join(start_dir, output_file_name)

    exclude_patterns = [
        '*/.cache*', '*/.local*', '*/.npm*', '*/.env*', '*/.ash_history*',
        '*/docker-compose.override.yml*', '*/pocketbase.exe', '*/pocketbase*.zip', '*/pb_data*', 
        '*/tmp*', '*/.DS_Store*', '*/node_modules*', '*/playwright-report*', '*/build*', 
        '*/.svelte-kit*', '*/package*', '*/.env*', '*/.env.*', '!*/.env.example*', '*/.txt',
        '*.pyc', '*.log', '*~', '*.tmp', '*.bak', '*.swp', '*.mod', '*/oldMigrations*',
        '*.dll', '*.exe', '*.png', '*.jpg', '*.jpeg', '*.gif', '*/.git*', '*/pb_migrations*',
        '*.yml', '*.yaml', '.gitignore', '*.sum', 'directory_contents_filtered_debug.txt','textGen.*' # Additional patterns
    ]

    tree_structure = {}
    with open(output_file_path, 'w', encoding='utf-8') as output_file:
        print(f"Starting directory traversal from {start_dir}")
        for root, dirs, files in os.walk(start_dir):
            print(f"Processing directory: {root}")
            dirs[:] = [d for d in dirs if not is_excluded(os.path.join(root, d), exclude_patterns)]
            files = [f for f in files if not is_excluded(os.path.join(root, f), exclude_patterns) and os.path.join(root, f) != output_file_path]
            
            # Update tree_structure
            path_parts = root.replace(start_dir, '').strip(os.sep).split(os.sep)
            current_level = tree_structure
            for part in path_parts:
                current_level = current_level.setdefault(part, {})
            for file in files:
                current_level[file] = {}

            for file in files:
                file_path = os.path.join(root, file)
                if is_binary(file_path):
                    continue
                
                try:
                    with open(file_path, 'r', encoding='utf-8', errors='ignore') as f:
                        contents = f.read()
                    output_file.write(f"Path: {file_path}\nContents:\n{contents}\n\n")
                    print(f"Included: {file_path}")
                except Exception as e:
                    print(f"Error processing file {file_path}: {e}")
        
        # Generate and write the tree view
        tree_view = generate_tree_view(start_dir, tree_structure)
        output_file.write(f"Project Tree View:\n{tree_view}")

# Example usage
output_file_name = "directory_contents_filtered_debug.txt"
parse_directory_to_file(output_file_name)


Path: D:\Modible\Software\pocketbase-sveltekit-starter\Things to do
Contents:
Need to extract the blog generation piece and setup the inspiration page.

Path: D:\Modible\Software\pocketbase-sveltekit-starter\.vscode\settings.json
Contents:
{
    "zenMode.showTabs": "multiple"
}

Path: D:\Modible\Software\pocketbase-sveltekit-starter\pb\.dockerignore
Contents:
# flyctl launch added from .gitignore
.cache
pocketbase
pocketbase*.zip
pb_data
tmp
fly.toml


Path: D:\Modible\Software\pocketbase-sveltekit-starter\pb\Dockerfile
Contents:
ARG GO_VERSION=1
FROM golang:${GO_VERSION}-bookworm as builder

WORKDIR /usr/src/app
COPY go.mod go.sum ./
RUN go mod download && go mod verify
COPY . .
RUN go build -v -o /run-app .


FROM debian:bookworm

COPY --from=builder /run-app /usr/local/bin/
CMD ["run-app"]


Path: D:\Modible\Software\pocketbase-sveltekit-starter\pb\entrypoint.sh
Contents:
#!/bin/sh
set -e # exit on any non-zero status (error)

# this entrypoint script checks that all required setup is done
# if not done, does it
# and then proceeds to execute the main "command" for this container

# build if needed
go mod tidy
go build

if [ ! -x "$(which modd)" ]; then
  echo "go install modd"
  go install github.com/cortesi/modd/cmd/modd@latest
fi

exec "$@"

Path: D:\Modible\Software\pocketbase-sveltekit-starter\pb\example-hook-script.sh
Contents:
#!/usr/bin/env bash

# This example script, along with hooks.go, shows how to trigger a command
# when a record changes in PocketBase and how to feed the changed record to this
# script.

params=$1 # `action_params` field passed from the "hooks" table
echo "PARAMS=$params"

# The body of the record (as JSON) is fed to this script as stdin.
# The following just reformats it and pretty-prints it.
cat | jq -C

Path: D:\Modible\Software\pocketbase-sveltekit-starter\pb\fly.toml
Contents:
# fly.toml app configuration file generated for pb1456 on 2024-03-24T17:43:43-05:00
#
# See https://fly.io/docs/reference/configuration/ for information about how to use this file.
#

app = 'pb1456'
primary_region = 'atl'

[build]
  [build.args]
    GO_VERSION = '1.22'

[env]
  PORT = '8080'

[http_service]
  internal_port = 8080
  force_https = true
  auto_stop_machines = true
  auto_start_machines = true
  min_machines_running = 0
  processes = ['app']

[[vm]]
  memory = '1gb'
  cpu_kind = 'shared'
  cpus = 1


Path: D:\Modible\Software\pocketbase-sveltekit-starter\pb\main.go
Contents:
package main

import (
	"bytes"
	"context"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"log"
	"net/http"
	"os"
	"path/filepath"
	"pocketbase/hooks"
	"strings"
	"time"

	"errors"

	"github.com/joho/godotenv"
	"github.com/labstack/echo/v5"
	"github.com/liushuangls/go-anthropic"
	"github.com/pocketbase/pocketbase"
	"github.com/pocketbase/pocketbase/apis"
	"github.com/pocketbase/pocketbase/core"
	"github.com/pocketbase/pocketbase/forms"
	"github.com/pocketbase/pocketbase/models"
	"github.com/pocketbase/pocketbase/plugins/jsvm"
	"github.com/pocketbase/pocketbase/plugins/migratecmd"
	"github.com/pocketbase/pocketbase/tools/filesystem"
)

type TextToImage struct {
	Base64       string `json:"base64"`
	Seed         uint32 `json:"seed"`
	FinishReason string `json:"finishReason"`
}

type TextToImageResponse struct {
	Images []TextToImage `json:"artifacts"`
}

// DreamStudioResponse is a placeholder for the actual response structure from DreamStudio.
type DreamStudioResponse struct {
	Images []struct {
		Base64 string `json:"base64"`
	} `json:"images"`
}

// ImageUploadResponse is the structure of the response returned after a successful image upload.
type ImageUploadResponse struct {
	ID string `json:"id"` // or URL if you prefer to return the image URL
}

const (
	PostsCollection         = "posts"
	ImagesCollection        = "images"
	DefaultAPIHost          = "https://api.stability.ai"
	StableDiffusionEngineID = "stable-diffusion-v1-6"
)

func defaultPublicDir() string {
	if strings.HasPrefix(os.Args[0], os.TempDir()) {
		// most likely ran with go run
		return "./pb_public/"
	}

	return filepath.Join(os.Args[0], "../pb_public/")
}

// use godot package to load/read the .env file and
// return the value of the key
func goDotEnvVariable(key string) string {

	// load .env file
	err := godotenv.Load(".env")

	if err != nil {
		log.Fatalf("Error loading .env file")
	}

	return os.Getenv(key)
}

func servicesHandler(c echo.Context) error {
	services := []map[string]interface{}{
		{
			"name":   "Anthropic",
			"models": []string{"claude-instant-v1", "claude-instant-v1-100k"},
		},
		{
			"name":   "OpenAI",
			"models": []string{"gpt-3.5-turbo", "gpt-4"},
		},
	}

	return c.JSON(http.StatusOK, services)
}

func claudeHandler(c echo.Context) error {
	var requestBody struct {
		Text  string `json:"text"`
		Model string `json:"model"`
	}

	if err := c.Bind(&requestBody); err != nil {
		return c.JSON(http.StatusBadRequest, map[string]string{"error": "Invalid request body"})
	}

	client := anthropic.NewClient(goDotEnvVariable("ANTHROPIC_API_KEY"))

	resp, err := client.CreateMessages(context.Background(), anthropic.MessagesRequest{
		Model: requestBody.Model,
		Messages: []anthropic.Message{
			anthropic.NewUserTextMessage(requestBody.Text),
		},
		MaxTokens: 1000,
	})
	if err != nil {
		var e *anthropic.APIError
		if errors.As(err, &e) {
			fmt.Printf("Messages error, type: %s, message: %s", e.Type, e.Message)
		} else {
			fmt.Printf("Messages error: %v\n", err)
		}
		return err
	}

	fmt.Println(resp.Content[0].Text)

	return c.JSON(http.StatusOK, map[string]interface{}{"result": resp.Content[0].Text})
}

func chatGptHandler(c echo.Context) error {
	var requestBody struct {
		Text  string `json:"text"`
		Model string `json:"model"`
	}

	log.Println("Received request to /api/openai")

	if err := c.Bind(&requestBody); err != nil {
		log.Printf("Error in chatGptHandler: %v", err)
		return c.JSON(http.StatusBadRequest, map[string]string{"error": "Invalid request"})
	}

	chatGPTAPIKey := goDotEnvVariable("CHATGPT_API_KEY")

	result, err := hooks.DoChatGPT(chatGPTAPIKey, requestBody.Text, requestBody.Model)
	if err != nil {
		log.Printf("Error in chatGptHandler: %v", err)
		return c.JSON(http.StatusInternalServerError, map[string]string{"error": "Failed to generate text from ChatGPT"})
	}

	return c.JSON(http.StatusOK, map[string]interface{}{"result": result})
}

func dalleImageHandler(c echo.Context) error {
	var requestBody struct {
		Prompt string `json:"prompt"`
	}

	if err := c.Bind(&requestBody); err != nil {
		return c.JSON(http.StatusBadRequest, map[string]string{"error": "Invalid request"})
	}

	dalleAPIKey := goDotEnvVariable("CHATGPT_API_KEY") // Ensure this is correctly named. Adjust according to your actual environment variable retrieval function
	prompt := requestBody.Prompt
	model := "dall-e-2" // Make sure to use the correct model name
	size := "512x512"   // Adjust based on what sizes your model supports

	b64Data, err := hooks.DoDalle3(dalleAPIKey, prompt, model, size)
	if err != nil {
		log.Printf("Error generating image: %v", err)
		return c.JSON(http.StatusInternalServerError, map[string]string{"error": "Failed to generate image"})
	}

	// Decode base64 string to []byte
	data, err := base64.StdEncoding.DecodeString(b64Data)
	if err != nil {
		log.Printf("Error decoding base64 data: %v", err)
		return c.JSON(http.StatusInternalServerError, map[string]string{"error": "Failed to decode image data"})
	}

	// Create a unique file name
	fileName := fmt.Sprintf("dalle_image_%v.png", time.Now().Unix())
	filePath := filepath.Join("./pb_public/", fileName) // Adjust the path as necessary

	// Write data to file
	err = os.WriteFile(filePath, data, 0644)
	if err != nil {
		log.Printf("Error writing image to file: %v", err)
		return c.JSON(http.StatusInternalServerError, map[string]string{"error": "Failed to save image file"})
	}

	// Construct the full URL to return
	url := fmt.Sprintf("http://localhost:8090/%s", fileName)

	// Return the full URL to the frontend
	return c.JSON(http.StatusOK, map[string]interface{}{"url": url})
}

func generateImage(requestBody map[string]interface{}, apiKey string) ([]byte, error) {
	// Build REST endpoint URL w/ specified engine
	apiHost := os.Getenv("API_HOST")
	if apiHost == "" {
		apiHost = "https://api.stability.ai"
	}

	reqUrl := apiHost + "/v1/generation/" + requestBody["engineId"].(string) + "/text-to-image"

	log.Printf("sending request to DreamStudio API: %v\n", reqUrl)

	jsonData, _ := json.Marshal(requestBody)

	req, _ := http.NewRequest("POST", reqUrl, bytes.NewBuffer(jsonData))
	req.Header.Add("Content-Type", "application/json")
	req.Header.Add("Accept", "application/json")
	req.Header.Add("Authorization", "Bearer "+apiKey)

	// Execute the request & read all the bytes of the body
	res, err := http.DefaultClient.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()

	if res.StatusCode != 200 {
		var body map[string]interface{}
		if err := json.NewDecoder(res.Body).Decode(&body); err != nil {
			return nil, fmt.Errorf("Non-200 response from DreamStudio API: %v", err)
		}
		return nil, fmt.Errorf("Non-200 response from DreamStudio API: %v", body)
	}

	// Decode the JSON body
	var body TextToImageResponse
	if err := json.NewDecoder(res.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("failed to decode DreamStudio response: %v", err)
	}

	if len(body.Images) == 0 {
		return nil, errors.New("no images returned from DreamStudio")
	}

	// Get the first generated image
	generatedImage := body.Images[0]

	//log.Printf("generated image: %v\n", generatedImage)

	// Decode the base64 image data
	imageBytes, err := base64.StdEncoding.DecodeString(generatedImage.Base64)
	if err != nil {
		return nil, fmt.Errorf("failed to decode image data: %v", err)
	}

	return imageBytes, nil
}


func dreamStudioHandler(c echo.Context, app *pocketbase.PocketBase) error {
	var requestBody struct {
		Prompt   string `json:"prompt"`
		EngineId string `json:"engineId"`
	}
	if err := c.Bind(&requestBody); err != nil {
		return c.JSON(http.StatusBadRequest, map[string]string{"error": "Invalid request body"})
	}

	// Acquire an API key from the environment
	apiKey := os.Getenv("STABILITY_API_KEY")
	if apiKey == "" {
		return c.JSON(http.StatusInternalServerError, map[string]string{"error": "Missing STABILITY_API_KEY environment variable"})
	}

	requestData := map[string]interface{}{
		"text_prompts": []map[string]string{
			{"text": requestBody.Prompt},
		},
		"cfg_scale": 7,
		"height":    1024,
		"width":     1024,
		"samples":   1,
		"steps":     30,
		"engineId":  "stable-diffusion-xl-1024-v1-0",
	}

	log.Printf("generating image with request data: %v\n", requestData)

	imageBytes, err := generateImage(requestData, apiKey)
	if err != nil {
		log.Printf("Failed to generate image: %v\n", err)
		return c.JSON(http.StatusInternalServerError, map[string]string{"error": "Failed to generate image"})
	}

	// Create a new record in the "images" collection
	collection, err := app.Dao().FindCollectionByNameOrId("images")
	if err != nil {
		log.Printf("Failed to find collection: %v\n", err)
		return c.JSON(http.StatusInternalServerError, map[string]string{"error": "Failed to find collection"})
	}

	record := models.NewRecord(collection)

	// Create a new form for the record
	form := forms.NewRecordUpsert(app, record)

	// Set the form data
	form.LoadData(map[string]any{
		"originalName": "generated_image.png",
		"size":         len(imageBytes),
		"contentType":  "image/png",
	})

	// Create a new file from the image bytes
	file, err := filesystem.NewFileFromBytes(imageBytes, "generated_image.png")
	if err != nil {
		log.Printf("Failed to create file from bytes: %v\n", err)
		return c.JSON(http.StatusInternalServerError, map[string]string{"error": "Failed to create file from bytes"})
	}

	// Add the file to the form
	form.AddFiles("file", file)

	// Validate and submit the form
	if err := form.Submit(); err != nil {
		log.Printf("Failed to save image record: %v\n", err)
		return c.JSON(http.StatusInternalServerError, map[string]string{"error": "Failed to save image record"})
	}

	return c.JSON(http.StatusOK, map[string]string{"id": record.Id})
}

func main() {
	app := pocketbase.New()

	var publicDirFlag string = "./pb_public" // Ensure this points to the correct directory

	// add "--publicDir" option flag
	app.RootCmd.PersistentFlags().StringVar(
		&publicDirFlag,
		"publicDir",
		defaultPublicDir(),
		"the directory to serve static files",
	)

	// load js files to allow loading external JavaScript migrations
	jsvm.MustRegister(app, jsvm.Config{
		HooksWatch: true, // make this false for production
	})

	// register the `migrate` command
	migratecmd.MustRegister(app, app.RootCmd, migratecmd.Config{
		TemplateLang: migratecmd.TemplateLangJS, // or migratecmd.TemplateLangGo (default)
		Automigrate:  true,
	})

	// call this only if you want to auditlog tables named in AUDITLOG env var
	//auditlog.Register(app)

	// call this only if you want to use the configurable "hooks" functionality
	app.OnBeforeServe().Add(func(e *core.ServeEvent) error {
		// Register routes
		e.Router.POST("/api/dalle", dalleImageHandler)
		e.Router.POST("/api/dreamstudio", func(c echo.Context) error { return dreamStudioHandler(c, app) })
		e.Router.GET("/api/services", servicesHandler)
		e.Router.POST("/api/anthropic", claudeHandler)
		e.Router.POST("/api/openai", chatGptHandler)
		e.Router.GET("/*", apis.StaticDirectoryHandler(os.DirFS(publicDirFlag), true))
		log.Println("Serving static files from", publicDirFlag)
		return nil
	})

	if err := app.Start(); err != nil {
		log.Fatal(err)
	}
}


Path: D:\Modible\Software\pocketbase-sveltekit-starter\pb\modd.conf
Contents:
# Run go test on ALL modules on startup, and subsequently only on modules
# containing changes.
**/*.go {
    prep: go build
    # prep: go test @dirmods
    daemon +sigterm: ./pocketbase serve --debug --http 0.0.0.0:8090 --publicDir ../sk/build
}


Path: D:\Modible\Software\pocketbase-sveltekit-starter\pb\README.md
Contents:
# Backend with PocketBase

There are two flavors of the backend:

1. Standard release downloaded from https://github.com/pocketbase/pocketbase/releases. It even allows [extending with JavaScript](https://pocketbase.io/docs/js-overview/). This one is a good start, but if you want full control see next.
2. Custom compiled (`go build`), possibly with my customizations and perhaps yours too.

Out of the box, the project assumes #2 (custom compiled with my customizations).

## standard (official) release of pocketbase

Download from release archive from https://github.com/pocketbase/pocketbase/releases/latest, unzip it and place the `pocketbase` binary in this folder, and you're done.

## custom build

If you would like to extend PocketBase and use it as a framework then there is a `main.go` in this folder that you can customize and build using `go build` or do live development using `modd`.

See https://pocketbase.io/docs/use-as-framework/ for details.

# Setup

## Architecture

> **Note:** For optimal set up, ensure you are using Linux (bare-metal, VM, WSL) or Docker. For other operating systems, you may run into issues, or need additional configuration.
> A docker-compose setup is included with the project, which can be used on any OS.

### TBD: For Windows users

_please contribute if you are a Windows user_

### TBD: For MacOS users

_please contribute if you are a MacOS user_

## Build

Assuming you have Go language tools installed ...

`go build`

If you don't have Go and don't want to install it, you can use docker-compose setup. Otherwise, your only choice is to download the binary from https://github.com/pocketbase/pocketbase/releases/latest, and placing it in this folder. But then you are limited to using JavaScript or configuration (but not Go-language customizations).

## Run migrations

Before you can run the actual backend, you must run the migrations using `./pocketbase migrate up` in the current directory. It will create appropriate schema tables/collections.

## Run the backend

You can run the PocketBase backend direct with `./pocketbase serve` or using `npm run backend` in the `sk` directory. Note that `npm run backend` it is included by default, but if you want the backend to also serve the frontend assets, then you must add the `--publicDir ../frontend/build` option. (Read more about this in [sk/package.json](../sk/package.json).)

## Docker

A highly recommended option is to run it inside a Docker container. A `Dockerfile` is included that builds a production Docker image. Also, a `docker-compose.yml` along with an _override_ file example are included, which should be used during development.

## Active development with `modd`

Finally, if you are going to actively develop using Go using PocketBase as a framework, then you probably want to use [modd](https://github.com/cortesi/modd), a development tool that rebuilds and restarts your Go binary everytime a source file changes (live reload on change). An basic `modd.conf` config file is included in this setup. You can run it by installing `modd` (`go install github.com/cortesi/modd/cmd/modd@latest`) and then running `modd`. All this is done automatically for you if you are using Docker.

# Schema (Collections)

With the 0.9 version of PocketBase, JavaScript auto-migrations as implemented. The JS files in `pb_migrations` can create/drop/modify collections and data. These are executed automatically by PocketBase on startup.

Not only that, they are also generated automatically whenever you change the schema! So go ahead and make changes to the schema and watch new JS files generated in the `pb_migrations` folder. Just remember to commit them to version control.

## Generated Types

The file `generated-types.ts` contains TypeScript definitions of `Record` types mirroring the fields in your database collections. But it needs to be regenerated every time you modify the schema. This can be done by simply running the `typegen` script in the frontend's `package.json`. So remember to do that.

# Hooks

PocketBase provides API's like .OnModelBefore* and .OnModelAfter* to run
callbacks when records change. This app builds on top of that by providing
a "hooks" table that drives those hooks using configuration. It has the
following fields:

- collection: name of the collection that triggers an action
- event: insert/update/delete event that triggers the action
- action_type: "command" if you want to run a program/script or "post" if
  you want to POST to a webhook endpoint. The record will be marshaled to
  JSON and passed to the command as STDIN or to the webhook POST as
  request body (with header 'content-type: application/json')
- action: path to the command/script or URL of the webhook to POST to
- action_params: a string that will be passed as argument to the action

So now by configuring the above table, you can execute external commands/scripts
and POST data to external webhooks in reaction to insert/update/delete of
records.

Most web services these days provide webhook endpoints (e.g. sendgrid, mailchimp, stripe, etc) which you can POST directly to. But if you need special
processing then you can write a script that receives changed data as JSON, parses and manipulates it using [`jq`](https://github.com/stedolan/jq) before
sending it on its way.

See `example-hook-script.sh` for a demonstration.

Possible use cases:

- Send an acknowledgement email when a "contact" form table is inserted to.
- Charge a credit card when payment_token table is inserted to and then
  send email upon success/failure
- Recalculate inventory levels as "orders" table is inserted to, and then
  send notifications when inventory becomes low.


Path: D:\Modible\Software\pocketbase-sveltekit-starter\pb\auditlog\auditlog.go
Contents:
package auditlog

import (
	"log"
	"os"
	"strings"

	"github.com/labstack/echo/v5"
	"github.com/pocketbase/pocketbase"
	"github.com/pocketbase/pocketbase/apis"
	"github.com/pocketbase/pocketbase/core"
	"github.com/pocketbase/pocketbase/models"
	"golang.org/x/exp/slices"
)

// collection names to be audit logged
var collections = strings.Split(os.Getenv("AUDITLOG"), ",")

func Register(app *pocketbase.PocketBase) {
	app.OnBeforeServe().Add(func(e *core.ServeEvent) error {
		app.OnRecordAfterCreateRequest().Add(func(e *core.RecordCreateEvent) error {
			return doAudit(app, "insert", e.Record, e.HttpContext)
		})
		app.OnRecordAfterUpdateRequest().Add(func(e *core.RecordUpdateEvent) error {
			return doAudit(app, "update", e.Record, e.HttpContext)
		})
		app.OnRecordAfterDeleteRequest().Add(func(e *core.RecordDeleteEvent) error {
			return doAudit(app, "delete", e.Record, e.HttpContext)
		})
		return nil
	})
}

func diff(val1, val2 any) bool {
	// handle comparison of non-comparable types
	// TODO: add more cases to the switch below as we discover them
	switch v1 := val1.(type) {
	case []string:
		v2 := val2.([]string)
		if len(v1) != len(v2) {
			return true
		}
		for i, v1 := range v1 {
			if diff(v1, v2[i]) {
				return true
			}
		}
		// no diff, if reached the end of the loop
		return false
	default:
		// use builtin comparison by default
		return val1 != val2
	}
}

func doAudit(app *pocketbase.PocketBase, event string, record *models.Record, ctx echo.Context) error {
	collection := record.Collection().Name
	// exclude logging "auditlog" and include only what's in AUDITLOG env var
	if collection != "auditlog" && slices.Contains(collections, collection) {
		var user, admin string
		if u, ok := ctx.Get(apis.ContextAdminKey).(*models.Admin); ok {
			admin = u.Id
		}
		if u, ok := ctx.Get(apis.ContextAuthRecordKey).(*models.Record); ok {
			user = u.Id
		}
		log.Printf("AuditLog:%s:%s:%s:%s:%s\n", collection, record.Id, event, user, admin)
		target, err := app.Dao().FindCollectionByNameOrId("auditlog")
		if err != nil {
			return err
		}
		auditlog := models.NewRecord(target)
		auditlog.Set("collection", collection)
		auditlog.Set("record", record.Id)
		auditlog.Set("event", event)
		auditlog.Set("user", user)
		auditlog.Set("admin", admin)
		// detect changes
		original := record.OriginalCopy().PublicExport()
		recordExport := record.PublicExport()
		for k, v := range original {
			if !diff(v, recordExport[k]) { // unmodified, then remove
				delete(original, k)
			}
		}
		auditlog.Set("data", recordExport)
		auditlog.Set("original", original)

		return app.Dao().SaveRecord(auditlog)
	}
	return nil
}


Path: D:\Modible\Software\pocketbase-sveltekit-starter\pb\data\email_templates\post.html
Contents:
<p>The following post was updated. Please review it for changes:</p>

<a href="{{ .meta.AppUrl }}/posts/{{ .record.slug }}/">{{ .record.title }}</a>


Path: D:\Modible\Software\pocketbase-sveltekit-starter\pb\hooks\email.go
Contents:
package hooks

import (
	"bytes"
	"encoding/json"
	"errors"
	"net/mail"

	"html/template"

	"github.com/pocketbase/pocketbase"
	"github.com/pocketbase/pocketbase/models"
	"github.com/pocketbase/pocketbase/tools/mailer"
)

var tpls *template.Template

func init() {
	tpls = template.Must(template.ParseGlob("./data/email_templates/*"))
}

// set IgnoreEmailVisibilityFlag for the record and it's expanded records (recursively)
func ignoreEmailVisibility(record *models.Record, value bool) {
	record.IgnoreEmailVisibility(value)
	for _, v := range record.Expand() {
		if child, ok := v.(*models.Record); ok {
			// recursively set ...
			ignoreEmailVisibility(child, value)
		}
	}
}

func doEmail(app *pocketbase.PocketBase, action, action_params string, record *models.Record) (err error) {
	// we have to IgnoreEmailVisibility(true) on the main record and all expanded relations in order
	// to include email fields in the exported JSON
	ignoreEmailVisibility(record, true)

	// Export record to JSON and import it back to convert it into map[string]any.
	// Should I use record.PublicExport() instead?
	ba, _ := json.Marshal(record)
	// log.Default().Println(string(ba))
	var _record map[string]any
	json.Unmarshal(ba, &_record)

	// build input data
	data := map[string]any{
		"record": _record,
		"meta":   app.Settings().Meta,
	}

	// populate template expressions within action_params to build params_json
	// example: {"to":"{{ .record.expand.creator.email }}", "subject": "ticket updated - {{ .record.title }}"}
	params_tpl, err := template.New("action_params").Parse(action_params)
	if err != nil {
		return
	}
	var params_json bytes.Buffer
	err = params_tpl.Execute(&params_json, data)
	if err != nil {
		return
	}

	// Unmarshal params_json into params and then inject that into data
	var params map[string]any
	err = json.Unmarshal(params_json.Bytes(), &params)
	if err != nil {
		return
	}
	data["params"] = params

	if _, ok := params["from"]; !ok {
		params["from"] = app.Settings().Meta.SenderName
	}
	if _, ok := params["to"]; !ok {
		return errors.New("action_params must provide 'to' key/value")
	}
	if _, ok := params["subject"]; !ok {
		return errors.New("action_params must provide 'subject' key/value")
	}

	var html bytes.Buffer
	err = tpls.ExecuteTemplate(&html, action, data)
	if err != nil {
		return
	}
	message := mailer.Message{
		From: mail.Address{
			Address: app.Settings().Meta.SenderAddress,
			Name:    params["from"].(string),
		},
		To: []mail.Address{
			{Address: params["to"].(string)},
		},
		Subject: params["subject"].(string),
		HTML:    html.String(),
		// Text:    string(ba),
	}
	return app.NewMailClient().Send(&message)
}


Path: D:\Modible\Software\pocketbase-sveltekit-starter\pb\hooks\hooks.go
Contents:
package hooks

import (
	"encoding/json"
	"fmt"
	"io"
	"log"
	"net/http"
	"os"
	"os/exec"
	"strings"

	"github.com/go-resty/resty/v2"
	"github.com/pocketbase/dbx"
	"github.com/pocketbase/pocketbase"
	"github.com/pocketbase/pocketbase/core"
	"github.com/pocketbase/pocketbase/models"
)

func PocketBaseInit(app *pocketbase.PocketBase) error {
	modelHandler := func(event string) func(e *core.ModelEvent) error {
		return func(e *core.ModelEvent) error {
			table := e.Model.TableName()
			// we don't want to executeEventActions if the event is a system event (e.g. "_collections" changes)
			if record, ok := e.Model.(*models.Record); ok {
				if table == "hooks" {
					log.Println("'hooks' collection changed. Unloading.")
					hookRowsMap = nil // just set it to nil and it will get re-loaded the next time it is needed
				} else {
					executeEventActions(app, event, table, record)
				}
			} else {
				log.Println("Skipping executeEventActions for table:", table)
			}
			return nil
		}
	}
	app.OnBeforeServe().Add(func(e *core.ServeEvent) error {
		// watch insert/update/delete of rows of all collections
		app.OnModelAfterCreate().Add(modelHandler("insert"))
		app.OnModelAfterUpdate().Add(modelHandler("update"))
		app.OnModelAfterDelete().Add(modelHandler("delete"))
		return nil
	})
	return nil
}

// cache of "hooks" table rows (all where disabled=false)
// key=collection:event, value=array-of-rows
var hookRowsMap map[string][]dbx.NullStringMap

func loadHookRows(db *dbx.DB) {
	if hookRowsMap != nil {
		return // already loaded
	}
	hookRowsMap = make(map[string][]dbx.NullStringMap)
	var rows []dbx.NullStringMap
	db.Select("*").
		From("hooks").
		Where(dbx.HashExp{"disabled": false}). // pick rows not disabled only
		All(&rows)
	for _, row := range rows {
		collection := row["collection"].String
		event := row["event"].String
		key := collection + ":" + event
		hookRowsMap[key] = append(hookRowsMap[key], row)
	}
}

func getHookRows(db *dbx.DB, collection, event string) []dbx.NullStringMap {
	loadHookRows(db)
	key := collection + ":" + event
	return hookRowsMap[key]
}

func DoChatGPT(apiKey, prompt string, model string) (string, error) {
	client := resty.New()

	response, err := client.R().
		SetAuthToken(apiKey).
		SetHeader("Content-Type", "application/json").
		SetBody(map[string]interface{}{
			"model":      model,
			"messages":   []interface{}{map[string]interface{}{"role": "system", "content": prompt}},
			"max_tokens": 800,
		}).
		Post("https://api.openai.com/v1/chat/completions")

	if err != nil {
		return "", err
	}

	var data map[string]interface{}
	err = json.Unmarshal(response.Body(), &data)
	if err != nil {
		return "", err
	}

	content := data["choices"].([]interface{})[0].(map[string]interface{})["message"].(map[string]interface{})["content"].(string)
	return content, nil
}

// DoDalle3 generates an image based on the prompt and returns a base64 encoded string.
func DoDalle3(apiKey, prompt, model, size string) (string, error) {
	client := resty.New()

	response, err := client.R().
		SetAuthToken(apiKey).
		SetHeader("Content-Type", "application/json").
		SetBody(map[string]interface{}{
			"model":           model,
			"n":               1,
			"prompt":          prompt,
			"size":            size,
			"response_format": "b64_json",
		}).
		Post("https://api.openai.com/v1/images/generations")

	if err != nil {
		return "", err
	}

	if response.StatusCode() != http.StatusOK {
		return "", fmt.Errorf("unexpected status code: %d, body: %s", response.StatusCode(), response.String())
	}

	// Log the response for debugging purposes
	/* logFile, err := os.OpenFile("api_responses.log", os.O_APPEND|os.O_CREATE|os.O_WRONLY, 0644)
	if err != nil {
		log.Fatal(err)
	}
	defer logFile.Close()
	log.SetOutput(logFile)
	log.Println("response", response.String()) */

	var respBody struct {
		Created int64                    `json:"created"`
		Data    []map[string]interface{} `json:"data"`
	}
	err = json.Unmarshal(response.Body(), &respBody)
	if err != nil {
		return "", err
	}

	if len(respBody.Data) == 0 {
		return "", fmt.Errorf("response data array is empty")
	}
	
	b64Data, ok := respBody.Data[0]["b64_json"].(string)
	if !ok {
		return "", fmt.Errorf("base64 image data not found in response")
	}

	// Here, instead of writing the data to a file, we return the base64 string
	return b64Data, nil
}

func executeEventActions(app *pocketbase.PocketBase, event string, table string, record *models.Record) {
	rows := getHookRows(app.DB(), table, event)
	for _, row := range rows {
		action_type := row["action_type"].String
		action := row["action"].String
		action_params := row["action_params"].String
		expands := strings.Split(row["expands"].String, ",")
		app.Dao().ExpandRecord(record, expands, func(c *models.Collection, ids []string) ([]*models.Record, error) {
			return app.Dao().FindRecordsByIds(c.Name, ids, nil)
		})
		if err := executeEventAction(app, event, table, action_type, action, action_params, record); err != nil {
			log.Println("ERROR", err)
		}
	}
}

func executeEventAction(app *pocketbase.PocketBase, event, table, action_type, action, action_params string, record *models.Record) error {
	log.Printf("event:%s, table: %s, action: %s\n", event, table, action)
	switch action_type {
	case "command":
		return doCommand(action, action_params, record)
	case "post":
		return doPost(action, action_params, record)
	case "email":
		return doEmail(app, action, action_params, record)
	default:
		return fmt.Errorf("unknown action_type: %s", action_type)
	}
}

func doCommand(action, action_params string, record *models.Record) error {
	cmd := exec.Command(action, action_params)
	if w, err := cmd.StdinPipe(); err != nil {
		return err
	} else {
		if r, err := cmd.StdoutPipe(); err != nil {
			return err
		} else {
			go func() {
				defer w.Close()
				defer r.Close()
				log.Println("-------------------------------")
				defer log.Println("-------------------------------")
				if err := cmd.Start(); err != nil {
					log.Printf("command start failed: %s %+v\n", action, err)
				} else {
					// write JSON into the pipe and close
					json.NewEncoder(w).Encode(record)
					w.Close()
					if err := cmd.Wait(); err != nil {
						log.Printf("command wait failed: %s %+v\n", action, err)
					}
				}
			}()
			// read pipe's stdout and copy to ours (in parallel to the above goroutine)
			io.Copy(os.Stdout, r)
		}
	}
	return nil
}

func doPost(action, action_params string, record *models.Record) error {
	r, w := io.Pipe()
	defer w.Close()
	go func() {
		defer r.Close()
		if resp, err := http.Post(action, "application/json", r); err != nil {
			log.Println("POST failed", action, err)
		} else {
			io.Copy(os.Stdout, resp.Body)
		}
	}()
	if err := json.NewEncoder(w).Encode(record); err != nil {
		log.Println("ERROR writing to pipe", err)
	}
	return nil
}

// This function would go in a new or existing file where you manage database interactions.
func processTagsForPost(db *pocketbase.PocketBase, postID string, tagsStr string) error {
	// Split the tags string by comma
	tags := strings.Split(tagsStr, ",")
	uniqueTags := make(map[string]bool)
	for _, tag := range tags {
			// Trim spaces and ensure tag is lowercase for consistency
			cleanTag := strings.ToLower(strings.TrimSpace(tag))
			if cleanTag != "" {
					uniqueTags[cleanTag] = true
			}
	}

	// Here you would interact with your database to find existing tags,
	// create new ones if necessary, and link them to the post via the taggings table.
	// The specifics of these operations depend on how you've set up your models
	// and how you interact with PocketBase collections.

	return nil // Implement error handling based on your logic
}


Path: D:\Modible\Software\pocketbase-sveltekit-starter\pb\pb_hooks\main.pb.ts
Contents:
// Extending PocketBase with JS - @see https://pocketbase.io/docs/js-overview/

/// <reference path="../pb_data/types.d.ts" />

routerAdd("GET", "/api/goodbye/:name", (c) => {
  let name = c.pathParam("name");
  return c.json(200, { message: "Goodbye " + name });
});

// sends email to the logged in user
routerAdd(
  "POST",
  "/api/sendmail",
  (c) => {
    const user = c.get("authRecord"); // obtain user record from context
    user.ignoreEmailVisibility(true); // required for user.get("email")
    const address = user.get("email"); // works only after user.ignoreEmailVisibility(true)
    const name = user.get("name");
    const message = new MailerMessage({
      from: {
        address: $app.settings().meta.senderAddress,
        name: $app.settings().meta.senderName,
      },
      to: [{ name, address }],
      subject: `test email from ${name}`,
      text: "Test email",
      html: "<strong>Test</strong> <em>email</em>",
    });
    $app.newMailClient().send(message);

    return c.json(200, { message });
  },
  // middleware(s)
  $apis.requireRecordAuth("users")
);


Path: D:\Modible\Software\pocketbase-sveltekit-starter\sk\.prettierignore
Contents:
.DS_Store
node_modules
/build
/.svelte-kit
/package
.env
.env.*
!.env.example

# Ignore files for PNPM, NPM and YARN
pnpm-lock.yaml
package-lock.json
yarn.lock


Path: D:\Modible\Software\pocketbase-sveltekit-starter\sk\.prettierrc
Contents:
{
  "useTabs": false,
  "singleQuote": false,
  "trailingComma": "es5",
  "printWidth": 80,
  "pluginSearchDirs": ["."],
  "overrides": [
    {
      "files": "*.svelte",
      "options": {
        "parser": "svelte"
      }
    }
  ],
  "plugins": ["prettier-plugin-tailwindcss"]
}


Path: D:\Modible\Software\pocketbase-sveltekit-starter\sk\playwright.config.ts
Contents:
import type { PlaywrightTestConfig } from "@playwright/test";

const config: PlaywrightTestConfig = {
  use: {
    headless: false,
    // viewport: { width: 1280, height: 768 },
    // video: "on-first-retry",
    // make sure "npm run dev" is running for localhost:5173 to work
    baseURL: "http://localhost:8090",
  },
  reporter: [["html"]],
};

export default config;


Path: D:\Modible\Software\pocketbase-sveltekit-starter\sk\postcss.config.cjs
Contents:
const tailwindcss = require("tailwindcss");
const autoprefixer = require("autoprefixer");

const config = {
  plugins: [
    //Some plugins, like tailwindcss/nesting, need to run before Tailwind,
    tailwindcss(),
    //But others, like autoprefixer, need to run after,
    autoprefixer,
  ],
};

module.exports = config;


Path: D:\Modible\Software\pocketbase-sveltekit-starter\sk\README.md
Contents:
# Static SvekteKit frontend for PocketBase backend

## Setup

```bash
npx pnpm install # install dependencies
npm run build # compile frontend
```

The above produces `build` output directory which is then used by PocketBase to serve the frontend of your app.

## Live Development

```bash
# start the backend, if not already running ...
npm run dev:backend
# and then start the frontend ...
npm run dev
```

Now visit http://localhost:5173 (sk) or http://localhost:8090 (pb)

## Generated Types

The file `generated-types.ts` contains TypeScript definitions of `Record` types mirroring the fields in your database collections. But it needs to be regenerated every time you modify the schema. This can be done by simply running the `typegen` script in the frontend's `package.json`. So remember to run `npm run typegen` after every schema change.

## Building

To create a production version of your app (static HTML/JS app):

_NOTE_: The build below will fail unless the backend has at least 1
post created. So please create a "posts" record using the app UI or
the admin UI before running build below.

```bash
# compile frontend
npm run build
# and then serve it with pocketbase
npm run backend
```

The above generates output in the `build` folder. Now you can serve production compiled version of the frontend using the backend (with `--publicDir ../frontend/build`), any static file web server, or `npm preview`.


Path: D:\Modible\Software\pocketbase-sveltekit-starter\sk\svelte.config.js
Contents:
import { vitePreprocess } from "@sveltejs/vite-plugin-svelte";
import adapter from "@sveltejs/adapter-static";
import preprocess from "svelte-preprocess";

/** @type {import('@sveltejs/kit').Config} */
const config = {
  preprocess: [
    preprocess({
      postcss: true,
    }),
    vitePreprocess(),
  ],

  kit: {
    adapter: adapter({
      pages: "build",
      assets: "build",
      fallback: "index.html",
      precompress: true,
      strict: true,
    }),
    paths: {
      base: process.env.BASE_PATH ?? "",
    },
    alias: {
      $lib: "src/lib",
    },
    prerender: {
      entries: ['*', '/posts/[slug]'],
    },
  },
};

export default config;


Path: D:\Modible\Software\pocketbase-sveltekit-starter\sk\tailwind.config.cjs
Contents:
const daisyui = require("daisyui");
const typography = require("@tailwindcss/typography");
const forms = require("@tailwindcss/forms");

/** @type {import('tailwindcss').Config}*/
const config = {
  content: ["./src/**/*.{html,js,svelte,ts}"],

  theme: {
    extend: {},
  },

  plugins: [forms, typography, daisyui],

  daisyui: {
    themes: [
      "light",
      "dark",
      "cupcake",
      "bumblebee",
      "emerald",
      "corporate",
      "synthwave",
      "retro",
      "cyberpunk",
      "valentine",
      "halloween",
      "garden",
      "forest",
      "aqua",
      "lofi",
      "pastel",
      "fantasy",
      "wireframe",
      "black",
      "luxury",
      "dracula",
      "cmyk",
      "autumn",
      "business",
      "acid",
      "lemonade",
      "night",
      "coffee",
      "winter",
      "dim",
      "nord",
      "sunset",
    ],
  },
};

module.exports = config;


Path: D:\Modible\Software\pocketbase-sveltekit-starter\sk\tsconfig.json
Contents:
{
  "extends": "./.svelte-kit/tsconfig.json",
  "compilerOptions": {
    "allowJs": true,
    "checkJs": true,
    "esModuleInterop": true,
    "forceConsistentCasingInFileNames": true,
    "resolveJsonModule": true,
    "skipLibCheck": true,
    "sourceMap": true,
    "strict": true
  }
  // Path aliases are handled by https://kit.svelte.dev/docs/configuration#alias
  //
  // If you want to overwrite includes/excludes, make sure to copy over the relevant includes/excludes
  // from the referenced tsconfig.json - TypeScript does not merge them in
}


Path: D:\Modible\Software\pocketbase-sveltekit-starter\sk\vite.config.ts
Contents:
import { sveltekit } from "@sveltejs/kit/vite";
import type { UserConfig } from "vite";
import fs from "fs";

// detect if we're running inside docker and set the backend accordingly
const pocketbase_url = fs.existsSync("/.dockerenv")
  ? "http://pb:8090" // docker-to-docker
  : "http://localhost:8090"; // localhost-to-localhost

const config: UserConfig = {
  plugins: [sveltekit()],
  server: {
    proxy: {
      // proxy "/api" and "/_" to pocketbase_url
      "/api": pocketbase_url,
      "/_": pocketbase_url,
    },
  },
};

export default config;


Path: D:\Modible\Software\pocketbase-sveltekit-starter\sk\src\app.d.ts
Contents:
import type { PocketBase } from "pocketbase"

declare global {
  namespace App {
    interface Locals {
      pb: PocketBase;
    }
  }
}

declare namespace App {
  export interface PageData {
    post?: {
      id: string;
      title: string;
      slug: string;
      body: string;
      tags: string[];
      blogSummary: string;
      featuredImage: string;
      userid: string;
      prompt: string;
    };
    featuredImageUrl?: string;
  }
}

Path: D:\Modible\Software\pocketbase-sveltekit-starter\sk\src\app.html
Contents:
<!doctype html>
<html lang="en" class="h-full" data-theme="dark">
  <head>
    <meta charset="utf-8" />
    <link rel="icon" href="%sveltekit.assets%/favicon.ico" />
    <meta name="viewport" content="width=device-width" />
    %sveltekit.head%
  </head>
  <body>
    <div>%sveltekit.body%</div>
  </body>
</html>


Path: D:\Modible\Software\pocketbase-sveltekit-starter\sk\src\app.pcss
Contents:



Path: D:\Modible\Software\pocketbase-sveltekit-starter\sk\src\app.scss
Contents:
/* Write your global styles here, in PostCSS syntax */
@tailwind base;
@tailwind components;
@tailwind utilities;

Path: D:\Modible\Software\pocketbase-sveltekit-starter\sk\src\lib\config.ts
Contents:
export const site = {
  name: "mind",
  source_url: "https://modible.com/mind",
  description:
    "Capture your inspiration and ideas with mind. A simple and elegant journaling app that helps you stay organized.",
};


Path: D:\Modible\Software\pocketbase-sveltekit-starter\sk\src\lib\app\stores.ts
Contents:
import { goto } from "$app/navigation";
import { authModel, client, save } from "$lib/pocketbase";
import type { PostsResponse, PostsRecord } from "$lib/pocketbase/generated-types";
import { ensureTagsExist, generateImageFromDreamStudio } from "$lib/utils/api";
import { alertOnFailure } from "$lib/pocketbase/ui";
import {
  promptFormat,
  titlePrompt,
  tagPrompt,
  blogSummaryPrompt,
  imagePrompt,
} from "$lib/utils/prompts";
import { get, writable } from 'svelte/store';
import type { ServiceModelSelection } from '$lib/services/generateBlog';

export interface Metadata {
  title?: string;
  description?: string;
  headline?: string;
}

export const metadata = writable<Metadata>({});

// Define the structure of the post data
interface PostData {
  title: string;
  slug: string;
  body: string;
  blogSummary: string;
  featuredImage: string;
  prompt: string;
  userid: string;
  tags: string[];
}

export const serviceModelSelectionStore = writable<ServiceModelSelection>({
  selectedService: '',
  selectedModel: '',
});


// Function to call the API
async function callAPI(selectedService: string, selectedModel: string, inputText: string): Promise<string> {
  if (!selectedService || !selectedModel) {
    throw new Error("Service or model not selected.");
  }

  const response = await fetch(`/api/${selectedService.toLowerCase()}`, {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({ text: inputText, model: selectedModel }),
  });

  if (!response.ok) {
    throw new Error("Network response was not ok");
  }

  const data = await response.json();
  return data.result;
}

// Main function to generate and save the blog post
export async function generateBlog(
  userInput: string,
  authModel: any
): Promise<void> {
  /* if (!authModel?.id) {
    console.error("User is not logged in.");
    alert("Please log in to save your post.");
    return;
  } */

  let post: PostData = {
    title: "",
    slug: "",
    body: "",
    blogSummary: "",
    featuredImage: "",
    prompt: "",
    userid: authModel.id,
    tags: [],
  };

  try {
    // Get the selected service and model from the store
    const { selectedService, selectedModel } = get(serviceModelSelectionStore);

    // Generate content
    post.body = await callAPI(selectedService, selectedModel, `${promptFormat}'${userInput}'`);
    post.title = await callAPI(selectedService, selectedModel, `${titlePrompt}'${post.body}'`);
    const tagString = await callAPI(selectedService, selectedModel, `${tagPrompt}'${post.body}'`);
    post.blogSummary = await callAPI(selectedService, selectedModel, `${blogSummaryPrompt}'${post.body}'`);

    // Generate slug
    post.slug = post.title.toLowerCase().replace(/\s+/g, "-").replace(/[^\w-]+/g, "").substring(0, 50);
    post.prompt = userInput;

    // Generate image
    const imageResponseText = await callAPI(selectedService, selectedModel, `${imagePrompt}'${post.body}'`);
    const base64Image = await generateImageFromDreamStudio(imageResponseText);

    // Upload image and save post
    const imageBlob = await fetch(`data:image/png;base64,${base64Image}`).then((res) => res.blob());
    if (imageBlob.size > 5242880) {
      throw new Error("Image size exceeds the maximum limit of 5MB.");
    }
    const formData = new FormData();
    formData.append("file", imageBlob, "postImage.png");
    const createdImageRecord = await client.collection("images").create(formData);
    post.featuredImage = createdImageRecord.id;

    // Save tags
    const tagsArray = tagString.split(",").map((tag) => tag.trim()).filter((tag) => tag);
    const tagIds = await ensureTagsExist(tagsArray);
    post.tags = tagIds;

    // Create the post
    const createdPost = await save("posts", post as PostsRecord, true) as unknown as PostsResponse;

    // Redirect to the newly created post
    goto(`${import.meta.env.VITE_APP_SK_URL}/posts/${createdPost.slug}`);
  } catch (error) {
    alertOnFailure(() => `Failed to generate and save post: ${error}`);
    throw error;
  }
}

Path: D:\Modible\Software\pocketbase-sveltekit-starter\sk\src\lib\components\Alerts.svelte
Contents:
<script lang="ts" context="module">
import { writable } from "svelte/store";

interface Alert {
  message: string;
  type: string;
  timeout?: number;
  html?: boolean;
}

export const alerts = {
  ...writable<Alert[]>([]),
  add({ message, type = "info", timeout = 0, html = false }: Alert) {
    const alert = { message, type, html };
    this.update((v) => [...v, alert]);
    if (timeout) {
      setTimeout(() => {
        dismiss(alert);
      }, timeout);
    }
  },
  info(message: string, timeout = 0) {
    this.add({ message, type: "info", timeout });
  },
  success(message: string, timeout = 0) {
    this.add({ message, type: "success", timeout });
  },
  warning(message: string, timeout = 0) {
    this.add({ message, type: "warning", timeout });
  },
  error(message: string, timeout = 0) {
    this.add({ message, type: "error", timeout });
  },
};

export function errorAlert(message: string) {
  const type = "error";
}

function dismiss(alert: Alert) {
  alerts.update((val) => val.filter((a) => a !== alert));
}

function dismissAll() {
  alerts.set([]);
}
</script>

<svelte:window
  on:unhandledrejection={(e) => alerts.error(e.reason.toString())}
/>

<article>
  {#if $alerts.length > 1}
    <button on:click={dismissAll} class="tight">Dismiss All</button>
  {/if}
  {#each $alerts as alert}
    <blockquote class={alert.type}>
      <button on:click={() => dismiss(alert)} class="dismiss">&times;</button>
      {#if alert.html}
        {@html alert.message}
      {:else}
        {alert.message}
      {/if}
    </blockquote>
  {/each}
</article>

<style>
</style>


Path: D:\Modible\Software\pocketbase-sveltekit-starter\sk\src\lib\components\DateShow.svelte
Contents:
<script lang="ts">
export let date: string;
let dt: Date,
  // year: number,
  // dom: number,
  // dow: number,
  // mon: number,
  year: string,
  dom: string,
  dowName: string,
  monName: string;
const days = ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"];

$: {
  dt = new Date(date);
  // year = dt.getFullYear();
  // dom = dt.getDate();
  // dow = dt.getDay();
  // mon = dt.getMonth();
  [dowName, monName, dom, year] = dt.toDateString().split(" ");
}
</script>

<div class="date" title={dt.toLocaleString()}>
  <div class="dow">{dowName}</div>
  <div>
    <div class="mon">{monName}</div>
    <div class="dom">{dom}</div>
  </div>
  <div class="year">{year}</div>
</div>

<style lang="scss">
.date {
  display: inline-flex;
  background-color: var(--border);
  border-radius: 50%;
  height: 5em;
  aspect-ratio: 1;
  padding: 0.5em;
  flex-direction: column;
  justify-content: center;
  align-items: center;
  font-family: var(--font-alt);
  > div {
    display: flex;
    flex-direction: row;
    gap: 0.25em;
    > * {
      font-weight: bold;
    }
  }
}
</style>


Path: D:\Modible\Software\pocketbase-sveltekit-starter\sk\src\lib\components\Delete.svelte
Contents:
<script lang="ts">
  import { onMount } from 'svelte';
  import { goto } from "$app/navigation";
  import { client } from "$lib/pocketbase";
  import { alertOnFailure } from "$lib/pocketbase/ui";
  import Image from "./Image.svelte"; // Make sure the path is correct
  import type { PostsResponse } from "$lib/pocketbase/generated-types";

  export let id: string;
  export let table: string;

  let post: PostsResponse | null = null;

  async function loadPost() {
    try {
      const fetchedPost = await client.collection(table).getOne(id);
      post = fetchedPost as unknown as PostsResponse;
    } catch (error) {
      console.error("Failed to load post", error);
      alert("Failed to load post details.");
    }
  }

  async function submit() {
    alertOnFailure(async () => {
      console.log(`Attempting to delete record with ID: ${id} from table: ${table}`);
      await client.collection(table).delete(id);
      goto("/remember");
    });
  }

  onMount(() => {
    loadPost();
  });
</script>

<div class="flex justify-center items-center h-screen">
  {#if post}
    <form on:submit|preventDefault={submit} class="card flex-shrink-0 w-full max-w-sm shadow-2xl bg-base-100">
      <div class="card-body">
        <figure>
          <Image {post} alt={post?.title || 'Post image'} className="w-full h-auto" />
        </figure>
        <h2 class="card-title">{post?.title}</h2>
        <p>Are you sure you want to delete this post?</p>
        <div class="card-actions justify-end">
          <button type="button" class="btn btn-outline btn-accent" on:click={() => goto("/remember")}>No - Cancel</button>
          <button type="submit" class="btn btn-primary">Yes - Proceed</button>
        </div>
      </div>
    </form>
  {:else}
    <p>Loading post details...</p>
  {/if}
</div>


Path: D:\Modible\Software\pocketbase-sveltekit-starter\sk\src\lib\components\Dialog.svelte
Contents:
<script lang="ts">
  export let open: boolean;

  function handleClose() {
    open = false;
  }
</script>

<dialog class="modal" {open} on:close={handleClose}>
  <div class="modal-box">
    <slot />    
    <div class="modal-action">
      <button class="btn btn-primary" on:click={handleClose}>Close</button>
    </div>
  </div>
</dialog>

<style>
  /* Add any necessary styles */
</style>

Path: D:\Modible\Software\pocketbase-sveltekit-starter\sk\src\lib\components\FileInput.svelte
Contents:
<script lang="ts">
import { createEventDispatcher } from "svelte";

export let files: FileList;
export let accept = ".*";
export let multiple = true;
export let pasteFile = false;
const dispatch = createEventDispatcher();
function paste(e: ClipboardEvent) {
  if (pasteFile && e.clipboardData?.files) {
    files = e.clipboardData.files;
    dispatch("change", files);
  }
}
</script>

<svelte:body on:paste={paste} />

<label class="file">
  <div><slot>Drag/drop files here.</slot></div>
  <input
    type="file"
    multiple={multiple}
    bind:files={files}
    on:change={(e) => dispatch("change", files)}
    accept={accept}
  />
</label>

<style lang="scss">
label.file {
  cursor: pointer;
  border: dashed 2px gray;
  padding: 1em;
  position: relative;
  display: flex;
  justify-content: center;
  input[type="file"] {
    position: absolute;
    width: 100%;
    height: 100%;
    top: 0;
    bottom: 0;
    left: 0;
    right: 0;
    opacity: 0;
    padding: 0;
    margin: 0;
    cursor: pointer;
  }
}
</style>


Path: D:\Modible\Software\pocketbase-sveltekit-starter\sk\src\lib\components\Image.svelte
Contents:
<script lang="ts">
import { client } from "$lib/pocketbase";
import type { PostsResponse } from "$lib/pocketbase/generated-types";

export let post: PostsResponse;
export let alt: string = "";
export let className: string = "";
</script>

<!-- Image.svelte -->
{#if post.expand?.featuredImage}
  {@const imageRecord = post.expand.featuredImage}
  {@const imageUrl = imageRecord && imageRecord.file ? client.getFileUrl(imageRecord, imageRecord.file) : ''}
  <img src={imageUrl} alt={alt} class={className} />
{:else}
  <img
    src="https://via.placeholder.com/800x400.png?text=No+Image"
    alt={alt}
    class={className}
  />
{/if}


Path: D:\Modible\Software\pocketbase-sveltekit-starter\sk\src\lib\components\ImageWall.svelte
Contents:
<script lang="ts">
    import { onMount } from "svelte";
    import { client } from "$lib/pocketbase";
    import type { ImagesResponse } from "$lib/pocketbase/generated-types";
  
    let images: ImagesResponse[] = [];
    let imageWallList: string[] = [];
  
    onMount(async () => {
      const result = await client.collection("images").getList(1, 50);
      images = result.items as ImagesResponse[];
      updateImageWallList(images);
    });
  
    function updateImageWallList(images: ImagesResponse[]) {
      imageWallList = images
        .filter((image) => image.file)
        .map((image) => client.files.getUrl(image, image.file!));
    }
  
    $: updateImageWallList(images);
  </script>
  
  <div class="grid grid-cols-1  sm:grid-cols-2 md:grid-cols-3 lg:grid-cols-4">
    {#each imageWallList as pic}
      <img src={pic} alt="Background" class="w-full h-auto" />
    {/each}
  </div>

Path: D:\Modible\Software\pocketbase-sveltekit-starter\sk\src\lib\components\InterpretationList.svelte
Contents:
<script lang="ts">
  import { createEventDispatcher } from "svelte";
  import { scale } from 'svelte/transition';

  export let interpretations: { title: string; text: string; imageUrl: string }[];

  const dispatch = createEventDispatcher();

  function selectInterpretation(interpretation: { title: string; text: string; imageUrl: string }) {
    dispatch("select", { interpretation });
  }

  function goBack() {
    dispatch("back");
  }
</script>

<style>
  .interpretation:hover {
    transform: translateY(-5px);
    transition: transform 0.3s ease;
  }
</style>

<div class="container mx-auto p-4">
  <div class="mb-6">
    <h2 class="text-2xl font-semibold mb-4 text-center">Select an interpretation:</h2>
    <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
      {#each interpretations as interpretation (interpretation.title)}
        <button class="max-w-sm rounded overflow-hidden shadow-lg cursor-pointer interpretation bg-primary text-primary-content hover:bg-secondary transition duration-300 ease-in-out transform hover:-translate-y-1 hover:scale-105" 
                on:click={() => selectInterpretation(interpretation)} 
                in:scale={{ duration: 300 }}>
          <img class="w-full" src={interpretation.imageUrl} alt={`Image for ${interpretation.title}`} in:scale={{ duration: 300 }}>
          <div class="px-6 py-4">
            <div class="font-bold text-xl mb-2 text-primary-content">{interpretation.title}</div>
            <p class="text-primary-content ">
              {interpretation.text}
            </p>
          </div>
        </button>
      {/each}
    </div>
  </div>
  <button class="btn btn-primary" on:click={goBack}>Back</button>
</div>


Path: D:\Modible\Software\pocketbase-sveltekit-starter\sk\src\lib\components\LoadingIndicator.svelte
Contents:
<script>
  // A reactive variable to hold the message
  export let message = "Loading...";
</script>

<div class="flex flex-col items-center justify-center h-72 min-h-[calc(100vh-200px)]">
  <div class="text-center">
    <svg class="h-8 w-8 animate-spin text-gray-800 mx-auto" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
      <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
      <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
    </svg>
    <p class="text-lg font-medium mt-4">{message}</p>
    <progress class="progress progress-primary w-56 mt-2" value="1" max="100"></progress>
  </div>
</div>


Path: D:\Modible\Software\pocketbase-sveltekit-starter\sk\src\lib\components\LoginBadge.svelte
Contents:
<script lang="ts">
import { onMount, onDestroy } from "svelte";
import { authModel, client } from "../pocketbase";
import Dialog from "./Dialog.svelte";
import LoginForm from "./LoginForm.svelte";
import { goto } from "$app/navigation";
import { fly } from "svelte/transition";
let isDialogOpen = false;
let isDropdownOpen = false;
async function logout() {
  goto("/");
  client.authStore.clear();
  isDialogOpen = false;
  isDropdownOpen = false;

  // Ensure dropdown is closed on logout
}

function getFileUrl(authModel: { id: any; }, avatar: any) {
  const baseUrl =
    import.meta.env.VITE_APP_BASE_URL + "/api/files/_pb_users_auth_";
  const userId = authModel.id;
  const fileName = avatar;
  const token = client.authStore.token;
  return `${baseUrl}/${userId}/${fileName}?token=${token}`;
}
const unsubscribe = client.authStore.onChange((token, model) => {
  // Handle auth state changes
}, false);
onDestroy(() => {
  unsubscribe();
});
</script>

<!-- Display user information and dropdown toggle -->
{#if $authModel}
  <div class="relative inline-block text-left">
    <button
      class="dropdown"
      on:click={() => (isDropdownOpen = !isDropdownOpen)}
      aria-haspopup="true"
      aria-expanded={isDropdownOpen}
    >
      <div tabindex="0" role="button" class="btn">
        {$authModel?.name || $authModel?.username || 'User'}
        
      </div>
    </button>
    {#if isDropdownOpen}
      <ul
        transition:fly={{ y: 10, duration: 200 }}
        class="dropdown-content menu bg-base-200 rounded-box absolute right-0 z-[1] mt-2 w-52 p-2 shadow"
      >
        <li>
          <button class="justify-between" on:click={() => (isDialogOpen = true)}
            >Profile</button
          >
        </li>
        <!-- Add more dropdown items here -->
        <li>
          <button class="flex" title="View profile">
            <img alt="Profile" src="/avatar.png" class="w-8 rounded-full" />
            <div class="flex flex-col">
              <h3 class="font-bold">User name</h3>
              <span class="text-accent text-xs">username@email.com</span>
            </div>
          </button>
        </li>
        <div class="divider my-0"></div>
        <li><button>Settings</button></li>
        <li><button>Keyboard shortcut</button></li>
        <div class="divider my-0"></div>
        <li><button>Company profile</button></li>
        <li><button>Team</button></li>
        <li><button>Invite Colleagues</button></li>
        <div class="divider my-0"></div>
        <li><button>Help</button></li>
        <li><button on:click={logout}>Sign out</button></li>
      </ul>
    {/if}
  </div>
{:else}
  <button class="btn btn-primary" on:click={() => (isDialogOpen = true)}
    >Sign In</button
  >
{/if}
<Dialog bind:open={isDialogOpen}>
  {#if $authModel}
    <!-- Logged in user's profile or logout option -->
    <div transition:fly={{ y: -10, duration: 200 }}>
      <button on:click={logout}>Sign Out</button>
    </div>
  {:else}
    <!-- Login form for users who are not logged in -->
    <div transition:fly={{ y: -10, duration: 200 }}><LoginForm /></div>
  {/if}
</Dialog>


Path: D:\Modible\Software\pocketbase-sveltekit-starter\sk\src\lib\components\LoginForm.svelte
Contents:
<script lang="ts">
export let authCollection = "users";
export let passwordLogin = true;
export let signup = true;
import { client, providerLogin } from "../pocketbase";
const coll = client.collection(authCollection);
let email: string;
let name: string;
let password: string;
let passwordConfirm: string;
let create = false;
let admin = false;
let activeTab = signup ? "SignUp" : "SignIn";
let errorMessage = "";
let successMessage = "";
async function submit() {
  if (create) {
    try {
      await coll.create({ email, name, password, passwordConfirm });
      successMessage = "User created successfully!";
      errorMessage = "";
    } catch (error) {
      console.error("Error creating user:", error);
      errorMessage = "Error creating user. Please try again.";
      successMessage = "";
    }
  } else if (admin) {
    try {
      await client.admins.authWithPassword(email, password);
      successMessage = "Admin authenticated successfully!";
      errorMessage = "";
    } catch (error) {
      console.error("Admin authentication error:", error);
      errorMessage =
        "Admin authentication failed. Please check your credentials.";
      successMessage = "";
    }
  } else {
    try {
      await coll.authWithPassword(email, password);
      successMessage = "User authenticated successfully!";
      errorMessage = "";
    } catch (error) {
      console.error("User authentication error:", error);
      errorMessage =
        "User authentication failed. Please check your credentials.";
      successMessage = "";
    }
  }
}
</script>

<form
  on:submit|preventDefault={submit}
  class="rounded-box bg-base-200 flex max-w-md flex-col gap-4 p-6"
>
  {#if passwordLogin}
    <h1 class="self-center text-3xl font-bold">
      {activeTab === 'SignIn' ? 'Log in' : 'Create an account'}
    </h1>

    <div class="tabs self-center">
      <button
        class="tab tab-bordered {activeTab === 'SignIn' ? 'tab-active' : ''}"
        on:click={() => (activeTab = 'SignIn', signup = false)}
        on:keydown={(event) => {
          if (event.key === 'Enter') {
            activeTab = 'SignIn';
            signup = false;
          }
        }}
        aria-label="Log in"
        type="button"
      >
        Log in
      </button>
      <button
        class="tab tab-bordered {activeTab === 'SignUp' ? 'tab-active' : ''}"
        on:click={() => (activeTab = 'SignUp', signup = true)}
        on:keydown={(event) => {
          if (event.key === 'Enter') {
            activeTab = 'SignUp';
            signup = true;
          }
        }}
        aria-label="Sign up"
      >
        Sign up
      </button>
    </div>

    {#await coll.listAuthMethods({ $autoCancel: false }) then methods}
      <div class="space-y-2">
        {#each methods.authProviders as p}
          <button
            class="btn btn-neutral w-full"
            type="button"
            on:click={() => providerLogin(p, coll)}
          >
            <i class="fa-brands fa-google text-primary mr-2"></i>
            {activeTab === 'SignIn' ? 'Log in' : 'Sign up'} with {p.name}
          </button>
        {/each}
      </div>
    {:catch}
      <!-- pocketbase not working -->
    {/await}

    <div class="divider">OR</div>

    {#if activeTab === 'SignIn'}
      <label class="form-control">
        <div class="label">
          <span class="label-text">Email</span>
        </div>
        <input
          class="input input-bordered"
          bind:value={email}
          required
          type="email"
          placeholder="email"
          id="email-input"
          autocomplete="email"
        />
      </label>

      <label class="form-control">
        <div class="label">
          <span class="label-text">Password</span>
        </div>
        <input
          class="input input-bordered"
          bind:value={password}
          required
          type="password"
          placeholder="password"
          id="password-input"
          autocomplete="current-password"
        />
      </label>

      <div class="form-control">
        <label class="label cursor-pointer gap-2 self-start">
          <input type="checkbox" class="checkbox" bind:checked={admin} />
          <span class="label-text">Admin</span>
        </label>
      </div>

      <button
        class="btn btn-primary"
        type="submit"
        on:click={() => (create = false)}
      >
        Log in
      </button>
    {:else if activeTab === 'SignUp'}
      <label class="form-control">
        <div class="label">
          <span class="label-text">Email</span>
        </div>
        <input
          class="input input-bordered"
          bind:value={email}
          required
          type="text"
          placeholder="email"
        />
      </label>

      <label class="form-control">
        <div class="label">
          <span class="label-text">Password</span>
        </div>
        <input
          class="input input-bordered"
          bind:value={password}
          required
          type="password"
          placeholder="password"
        />
      </label>

      <label class="form-control">
        <div class="label">
          <span class="label-text">Confirm password</span>
        </div>
        <input
          class="input input-bordered"
          bind:value={passwordConfirm}
          required
          type="password"
          placeholder="confirm password"
        />
      </label>

      <label class="form-control">
        <div class="label">
          <span class="label-text">Name / Label</span>
        </div>
        <input
          class="input input-bordered"
          bind:value={name}
          required
          type="text"
          placeholder="name / label"
        />
      </label>

      <input type="hidden" name="register" value={true} />

      <button
        class="btn btn-primary"
        type="submit"
        on:click={() => (create = true)}
      >
        Sign up
      </button>
    {/if}

    {#if errorMessage}
      <div class="alert alert-error">
        <div class="flex-1">
          <svg
            xmlns="http://www.w3.org/2000/svg"
            fill="none"
            viewBox="0 0 24 24"
            class="mx-2 h-6 w-6 stroke-current"
          >
            <path
              stroke-linecap="round"
              stroke-linejoin="round"
              stroke-width="2"
              d="M18.364 18.364A9 9 0 005.636 5.636m12.728 12.728A9 9 0 015.636 5.636m12.728 12.728L5.636 5.636"
            ></path>
          </svg>
          <label>{errorMessage}</label>
        </div>
      </div>
    {/if}

    {#if successMessage}
      <div class="alert alert-success">
        <div class="flex-1">
          <svg
            xmlns="http://www.w3.org/2000/svg"
            fill="none"
            viewBox="0 0 24 24"
            class="mx-2 h-6 w-6 stroke-current"
          >
            <path
              stroke-linecap="round"
              stroke-linejoin="round"
              stroke-width="2"
              d="M3 7v10a2 2 0 002 2h14a2 2 0 002-2V9a2 2 0 00-2-2h-6l-2-2H5a2 2 0 00-2 2z"
            ></path>
          </svg>
          <label>{successMessage}</label>
        </div>
      </div>
    {/if}
  {/if}
</form>


Path: D:\Modible\Software\pocketbase-sveltekit-starter\sk\src\lib\components\LoginGuard.svelte
Contents:
<script lang="ts">
import { goto } from "$app/navigation";
import { Admin } from "pocketbase";
import { authModel } from "../pocketbase";
import LoginForm from "./LoginForm.svelte";
export let admin: boolean | undefined = undefined;
export let slotLogin = false;
export let destination: string | null = null;
$: if (destination != null && $authModel) {
  goto(destination);
}
$: authorized =
  $authModel && //  must be logged in
  (admin === undefined || // admin or not, doesn't matter
    (admin === true && $authModel instanceof Admin) || // must be admin
    (admin === false && !($authModel instanceof Admin))); // must not be admin
</script>

{#if authorized}
  <slot />
{:else if slotLogin || $$slots["login"]}
  <slot name="login">
    <LoginForm />
  </slot>
{/if}


Path: D:\Modible\Software\pocketbase-sveltekit-starter\sk\src\lib\components\Nav.svelte
Contents:
<script lang="ts">
import { base } from "$app/paths";
import { page } from "$app/stores";
import LoginBadge from "$lib/components/LoginBadge.svelte";
import { authModel } from "$lib/pocketbase";
import ThemeSwitch from "$lib/components/ThemeSwitch.svelte";
import { fly } from "svelte/transition";
let isOpen = false;
const appLinks = [
  ["/create/", "Create"],
  ["/remember/", "Remember"],
  //,
  ["/inspire/", "Inspire"],
  //["/explore/", "Explore"],
  //["/reflect/", "Reflect"],
];
const landingLinks = [
  ["/#features", "Features"],
  ["/#how-it-works", "How It Works"],
  ["/#pricing", "Pricing"],
  ["/#testimonials", "Testimonials"],
  ["/#contact", "Contact"],
];
function toggleMenu() {
  isOpen = !isOpen;
}
function closeMenu() {
  isOpen = false;
}
</script>

<nav>
  <div class="navbar">
    <div class="navbar-start">
      <div
        class="dropdown"
        on:mouseleave={closeMenu}
        role="button"
        aria-haspopup="true"
        aria-expanded={isOpen}
        tabindex={0}
      >
        <button
          class="btn btn-ghost lg:hidden"
          on:click={toggleMenu}
          tabindex="0"
        >
          <svg
            xmlns="http://www.w3.org/2000/svg"
            class="h-5 w-5"
            fill="none"
            viewBox="0 0 24 24"
            stroke="currentColor"
          >
            <path
              stroke-linecap="round"
              stroke-linejoin="round"
              stroke-width="2"
              d="M4 6h16M4 12h8m-8 6h16"
            />
          </svg>
        </button>
        {#if isOpen}
          <ul
            transition:fly={{ y: -10, duration: 200 }}
            class="menu menu-compact dropdown-content rounded-box bg-base-300 z-20 mt-3 w-52 p-2 shadow"
          >
            {#if $authModel}
              {#each appLinks as [path, label]}
                <li>
                  <a
                    href={`${base}${path}`}
                    class:active={$page.url.pathname === path}
                    on:click={closeMenu}>{label}</a
                  >
                </li>
              {/each}
            {:else}
              {#each landingLinks as [path, label]}
                <li><a href={path} on:click={closeMenu}>{label}</a></li>
              {/each}
            {/if}
            <ThemeSwitch />
          </ul>
        {/if}
      </div>
      <a href="/" class="btn btn-ghost text-xl normal-case">mind.ai</a>
    </div>
    <div class="navbar-center hidden lg:flex">
      <ul class="menu menu-horizontal p-0">
        {#if $authModel}
          {#each appLinks as [path, label]}
            <li class="p-4">
              <a
                href={`${base}${path}`}
                class:active={$page.url.pathname === path}>{label}</a
              >
            </li>
          {/each}
          <li class="p-4">
            <ThemeSwitch />
          </li>
        {:else}
          {#each landingLinks as [path, label]}
            <li class="p-4"><a href={path}>{label}</a></li>
          {/each}
        {/if}
      </ul>
    </div>
    <div class="navbar-end"><LoginBadge /></div>
  </div>
</nav>


Path: D:\Modible\Software\pocketbase-sveltekit-starter\sk\src\lib\components\PostCard.svelte
Contents:
<script lang="ts">
import type { PostsResponse } from "$lib/pocketbase/generated-types";
import Markdown from "svelte-markdown";
import TagGroup from "$lib/components/TagGroup.svelte";
import Delete from "./Delete.svelte";
import { client } from "$lib/pocketbase";
export let post: PostsResponse;
</script>

<div
  class="card bg-base-100 border-secondary border-3 m-2 flex flex-1 flex-col justify-between border shadow-xl"
>
  <div>
    <figure>
      <!-- PostCard.svelte -->
      {#if post.expand?.featuredImage}
        {@const imageRecord = post.expand.featuredImage}
        {@const imageUrl = imageRecord && imageRecord.file ? client.getFileUrl(imageRecord, imageRecord.file) : ''}
        <img
          src={imageUrl}
          alt={post.title}
          class="aspect-[16/9] w-full rounded-t-lg object-cover sm:aspect-[2/1] lg:aspect-[3/2]"
        />
      {:else}
        <img
          src="https://via.placeholder.com/800x400.png?text=AI+Blog"
          alt="Placeholder"
          class="aspect-[16/9] w-full rounded-t-lg object-cover sm:aspect-[2/1] lg:aspect-[3/2]"
        />
      {/if}
    </figure>
    <div class="">
      <div class="prose items-center p-2">
        <time datetime={post.updated} class="text-accent">
          {new Date(post.updated).toLocaleDateString()}
        </time>
      </div>
      <div class="group relative px-2">
        <a
          href={`/posts/${post.slug}`}
          class="prose-lg text-primary hover:text-secondary font-bold"
        >
          {post.title}
        </a>
        <div class="prose-sm text-base-content mt-3 line-clamp-6 text-justify">
          <Markdown source={post.blogSummary} />
        </div>
      </div>
    </div>
  </div>
  <div>
    <div class="p-2">
      <TagGroup post={post} />
      <div class="card-actions mt-4 justify-between">
        <a class="btn btn-outline" href={`/posts/${post.slug}/edit`}>Edit</a>
        <a class="btn btn-outline" href={`/posts/${post.slug}/inspire`}
          >Inspire</a
        >
        <a
          class="btn btn-outline btn-secondary"
          href={`/posts/${post.slug}#delete`}>Delete</a
        >
      </div>
    </div>
  </div>
</div>


Path: D:\Modible\Software\pocketbase-sveltekit-starter\sk\src\lib\components\PostContent.svelte
Contents:
<script lang="ts">
    import { marked } from "marked";
  
    export let content: string;
  </script>
  
  <div class="mt-4">
    {@html marked(content || "")}
  </div>

Path: D:\Modible\Software\pocketbase-sveltekit-starter\sk\src\lib\components\PostList.svelte
Contents:
<script lang="ts">
import type { PostsResponse } from "$lib/pocketbase/generated-types";
import PostCard from "$lib/components/PostCard.svelte";
export let posts: PostsResponse[] = [];
</script>

{#if Array.isArray(posts)}
  {#each posts as post (post.id)}
    <PostCard post={post} />
  {/each}
{:else}
  <p>Error: Posts data is not available.</p>
{/if}


Path: D:\Modible\Software\pocketbase-sveltekit-starter\sk\src\lib\components\ServiceForm.svelte
Contents:
<script lang="ts">
    import { createEventDispatcher } from 'svelte';
  
    const dispatch = createEventDispatcher();
    let selectedService = '';
    let selectedModel = '';
    let inputText = '';
  
    const services = [
      {
        name: "Anthropic",
        models: [
          "claude-3-haiku-20240307",
          "claude-3-sonnet-20240229",
          "claude-3-opus-20240229",
          "claude-2.1",
          "claude-2.0",
          "claude-instant-1.2",
        ],
      },
      {
        name: "OpenAI",
        models: ["gpt-4-turbo-preview", "gpt-3.5-turbo"],
      },
    ];
  
    async function callAPI() {
      // Emit an event with the selected service, model, and input text
      dispatch('submit', { selectedService, selectedModel, inputText });
    }
  </script>
  
  <div>
    <select bind:value={selectedService}>
      <option value="">Select a service</option>
      {#each services as service}
        <option value={service.name}>{service.name}</option>
      {/each}
    </select>
  
    {#if selectedService}
      <select bind:value={selectedModel}>
        <option value="">Select a model</option>
        {#each services.find(s => s.name === selectedService)?.models ?? [] as model}
          <option value={model}>{model}</option>
        {/each}
      </select>
    {/if}
  
    <input type="text" bind:value={inputText} placeholder="Enter text" />
    <button on:click={callAPI} disabled={!selectedService || !selectedModel}>
      Submit
    </button>
  </div>

Path: D:\Modible\Software\pocketbase-sveltekit-starter\sk\src\lib\components\ServiceSelector.svelte
Contents:
<script lang="ts">
  import { createEventDispatcher, onMount } from "svelte";
  import { availableServices } from "$lib/utils/api";

  export let selectedService: string = availableServices[0]?.name ?? '';
  export let selectedModel: string = availableServices[0]?.models[0] ?? '';

  const dispatch = createEventDispatcher();

  // Set default values on mount if not provided
  onMount(() => {
    if (!selectedService) {
      selectedService = availableServices[0].name;
      dispatch("serviceChange", selectedService);
    }
    if (!selectedModel) {
      selectedModel = availableServices.find(s => s.name === selectedService)?.models[0] ?? '';
      dispatch("modelChange", selectedModel);
    }
  });

  function handleServiceChange() {
    dispatch("serviceChange", selectedService);
    selectedModel = availableServices.find(s => s.name === selectedService)?.models[0] ?? '';
    dispatch("modelChange", selectedModel);
  }

  function handleModelChange() {
    dispatch("modelChange", selectedModel);
  }
</script>

<div class="flex bg-primary items-center text-primary-content">
  <select class="select select-ghost w-full max-w-xs" bind:value={selectedService} on:change={handleServiceChange}>
    {#each availableServices as service}
      <option value={service.name}>{service.name}</option>
    {/each}
  </select>
  {#if selectedService}
    <select class="select select-ghost w-full max-w-xs" bind:value={selectedModel} on:change={handleModelChange}>
      {#each availableServices.find(s => s.name === selectedService)?.models ?? [] as model}
        <option value={model}>{model}</option>
      {/each}
    </select>
  {/if}
</div>

Path: D:\Modible\Software\pocketbase-sveltekit-starter\sk\src\lib\components\Spinner.svelte
Contents:
<script lang="ts" context="module">
import { writable } from "svelte/store";

// returns a store that:
// starts out false
// becomes true when the async function f starts running
// becomes false when f resolves (or rejects)
export function activityStore<T>(f: (t: T) => Promise<any>) {
  const store = writable(false);
  async function run(data: T) {
    try {
      store.set(true);
      return await f(data);
    } finally {
      store.set(false);
    }
  }
  return { ...store, run };
}
</script>

<script lang="ts">
export let active = false;
</script>

<span class="loader" class:active={active} />

<style lang="scss">
.loader {
  width: 1em;
  height: 1em;
  border: 0.2em solid var(--links);
  border-radius: 50%;
  display: inline-block;
  box-sizing: border-box;
  &.active {
    border-bottom-color: transparent; // 3/4 border solid, 1/4 transparent
    animation: rotation 1s linear infinite;
  }
}

@keyframes rotation {
  0% {
    transform: rotate(0deg);
  }
  100% {
    transform: rotate(360deg);
  }
}
</style>


Path: D:\Modible\Software\pocketbase-sveltekit-starter\sk\src\lib\components\Tab.svelte
Contents:
<script lang="ts">
export let key: string | number;
import { getContext } from "svelte";
import type { Writable } from "svelte/store";
const store: Writable<string | number> = getContext("activeTab");
</script>

<button
  type="button"
  class="title"
  on:click={() => ($store = key)}
  class:active={$store === key}
>
  <slot />
</button>

<style>
</style>


Path: D:\Modible\Software\pocketbase-sveltekit-starter\sk\src\lib\components\TabContent.svelte
Contents:
<script lang="ts">
export let key: string | number;
import { getContext } from "svelte";
import type { Writable } from "svelte/store";
const store: Writable<string | number> = getContext("activeTab");
</script>

{#if $store === key}
  <slot />
{/if}


Path: D:\Modible\Software\pocketbase-sveltekit-starter\sk\src\lib\components\TabGroup.svelte
Contents:
<script lang="ts">
export let active: string | number = 0;
import { writable } from "svelte/store";
import type { Writable } from "svelte/store";
import { setContext } from "svelte";
const store: Writable<string | number> = writable(active);
  
setContext("activeTab", store);

</script>

<div class="tabs">
  <slot name="tabs" />
</div>

<div class="tab-content">
  <slot />
</div>

<style>
.tabs {
  border-bottom: 2px solid var(--tab-color-active-bg, white);
}
.tab-content {
  padding: 1em 0;
}
</style>


Path: D:\Modible\Software\pocketbase-sveltekit-starter\sk\src\lib\components\TagEditor.svelte
Contents:
<script lang="ts">
import TagGroup from "$lib/components/TagGroup.svelte";
import type { PostsResponse } from "$lib/pocketbase/generated-types";
import { client } from "$lib/pocketbase";
import { onMount } from "svelte";

export let post: PostsResponse;
let tags: string[] = [];
let tagInput: string = "";

onMount(async () => {
  await loadTags();
  tagInput = tags.join(", ");
});

async function loadTags() {
  if (post.expand?.tags) {
    tags = post.expand.tags.map((tag: { title: any }) => tag.title);
  } else {
    const postsTagsResponse = await client
      .collection("postsTags")
      .getList(1, 50, {
        filter: `posts = "${post.id}"`,
      });
    const tagIds = postsTagsResponse.items.map((postTag) => postTag.tags);
    const loadedTags = await Promise.all(
      tagIds.map((tagId) => client.collection("tags").getOne(tagId))
    );
    tags = loadedTags.map((tag) => tag.title);
  }
}

$: {
  if (post) {
    loadTags();
  }
}

function handleInput(event: Event) {
  const input = (event.target as HTMLInputElement).value;
  tagInput = input;
  tags = input
    .split(",")
    .map((tag) => tag.trim())
    .filter((tag) => tag);
}

$: {
  if (post) {
    loadTags();
  }
}
</script>

<div class="mt-4">
  <input
    type="text"
    bind:value={tagInput}
    on:input={handleInput}
    class="input input-bordered w-full"
    placeholder="Enter tags separated by commas"
  />
</div>

<TagGroup post={post} tags={tags} />


Path: D:\Modible\Software\pocketbase-sveltekit-starter\sk\src\lib\components\TagGroup.svelte
Contents:
<script lang="ts">
import { fade, scale } from "svelte/transition";
import type { PostsResponse } from "$lib/pocketbase/generated-types";
export let post: PostsResponse;
export let tags: string[] = [];
$: {
  if (post && post.tags) {
    tags = post.tags;
  }
}
</script>

{#if tags.length > 0}
  <div class="flex flex-wrap pb-2 pt-4" in:fade={{ duration: 400 }}>
    {#each tags as tag, i (tag)}
      {#if i < 2}
        <a
          href={`/tags/${tag}`}
          class="tag bg-primary-content text-accent hover:bg-primary-focus mb-2 mr-2 inline-block cursor-pointer px-2 py-1 text-sm"
          in:scale={{ delay: i * 100, duration: 500 }}
          out:fade={{ duration: 300 }}
        >
          #{tag}
        </a>
      {/if}
    {/each}
  </div>
{:else}
  <div class="px-6 pb-2 pt-4 text-sm font-semibold" in:fade={{ duration: 400 }}>
    No tags
  </div>
{/if}

<style>
.tag:hover {
  transform: translateY(-5px);
  transition: transform 0.3s ease;
}
</style>


Path: D:\Modible\Software\pocketbase-sveltekit-starter\sk\src\lib\components\ThemeSwitch.svelte
Contents:
<script>
import { onMount } from "svelte";
import { themes } from "$lib/utils/themes";

let currentTheme = "light";
/**
 * @type {HTMLDialogElement}
 */
let modal;

/**
 * @param {string} themeId
 */
function changeTheme(themeId) {
  const theme = themes.find((t) => t.id === themeId);
  if (theme) {
    document.documentElement.setAttribute("data-theme", theme.id);
    currentTheme = theme.id;
    localStorage.setItem("theme", theme.id);
    modal.close();
  }
}

onMount(() => {
  const savedTheme = localStorage.getItem("theme");
  if (savedTheme && themes.some((t) => t.id === savedTheme)) {
    changeTheme(savedTheme);
  }
});
</script>

<button
  type="button"
  on:click={() => modal.showModal()}
  aria-label="Open Theme Modal">Theme</button
>

<dialog bind:this={modal} class="modal" id="modal">
  <div class="modal-box w-11/12 max-w-5xl">
    <h3 class="text-lg font-bold">Select a Theme</h3>
    <div class="grid grid-cols-1 gap-4 py-4 md:grid-cols-2 lg:grid-cols-3">
      {#each themes as theme (theme.id)}
        <button
          class="border-base-content/20 hover:border-base-content/40 cursor-pointer overflow-hidden rounded-lg border outline outline-2 outline-offset-2 outline-transparent"
          data-set-theme={theme.id}
          data-act-class="!outline-base-content"
          on:click={() => changeTheme(theme.id)}
        >
          <div
            data-theme={theme.id}
            class="bg-base-100 text-base-content w-full font-sans"
          >
            <div class="grid grid-cols-5 grid-rows-3">
              <div class="bg-base-200 col-start-1 row-span-2 row-start-1"></div>
              <div class="bg-base-300 col-start-1 row-start-3"></div>
              <div
                class="bg-base-100 col-span-4 col-start-2 row-span-3 row-start-1 flex flex-col gap-1 p-2"
              >
                <div class="font-bold">{theme.name}</div>
                <div class="flex flex-wrap gap-1">
                  <div
                    class="bg-primary flex aspect-square w-5 items-center justify-center rounded lg:w-6"
                  >
                    <div class="text-primary-content text-sm font-bold">A</div>
                  </div>
                  <div
                    class="bg-secondary flex aspect-square w-5 items-center justify-center rounded lg:w-6"
                  >
                    <div class="text-secondary-content text-sm font-bold">
                      A
                    </div>
                  </div>
                  <div
                    class="bg-accent flex aspect-square w-5 items-center justify-center rounded lg:w-6"
                  >
                    <div class="text-accent-content text-sm font-bold">A</div>
                  </div>
                  <div
                    class="bg-neutral flex aspect-square w-5 items-center justify-center rounded lg:w-6"
                  >
                    <div class="text-neutral-content text-sm font-bold">A</div>
                  </div>
                </div>
              </div>
            </div>
          </div>
        </button>
      {/each}
    </div>
  </div>
  <form method="dialog" class="modal-backdrop">
    <button>Close</button>
  </form>
</dialog>


Path: D:\Modible\Software\pocketbase-sveltekit-starter\sk\src\lib\components\TreeView.svelte
Contents:
<script>
    import { onMount } from 'svelte';
  
    /**
     * @type {any[]}
     */
    export let treeData = [];
    /**
     * @type {any[]}
     */
    let selectedNodes = [];
  
    onMount(async () => {
      // Fetch the JSON data from a file or API
      //const response = await fetch('path/to/your/data.json');
      //treeData = await response.json();
    });
  
    /**
     * @param {any} node
     */
    function toggleNode(node) {
      const index = selectedNodes.indexOf(node);
      if (index > -1) {
        selectedNodes.splice(index, 1);
      } else {
        selectedNodes.push(node);
        selectChildren(node);
      }
      selectedNodes = [...selectedNodes];
    }
  
    /**
     * @param {{ children: any[]; }} node
     */
    function selectChildren(node) {
      if (node.children) {
        node.children.forEach((/** @type {any} */ child) => {
          if (!selectedNodes.includes(child)) {
            selectedNodes.push(child);
            selectChildren(child);
          }
        });
      }
    }
  </script>
  
  <ul class="pl-4">
    {#each treeData as node}
      <li class="mb-2">
        <label class="flex items-center">
          <input type="checkbox" class="checkbox checkbox-primary" on:change={() => toggleNode(node)} checked={selectedNodes.includes(node)}>
          <span class="ml-2">{node.name}</span>
        </label>
        {#if node.children}
          <svelte:self treeData={node.children} bind:selectedNodes />
        {/if}
      </li>
    {/each}
  </ul>

Path: D:\Modible\Software\pocketbase-sveltekit-starter\sk\src\lib\pocketbase\generated-types.ts
Contents:
/**
* This file was @generated using pocketbase-typegen
*/

export enum Collections {
	Images = "images",
	Posts = "posts",
	Subpost = "subpost",
	Tags = "tags",
	Users = "users",
}

// Alias types for improved usability
export type IsoDateString = string
export type RecordIdString = string

// System fields
export type BaseSystemFields = {
	id: RecordIdString
	created: IsoDateString
	updated: IsoDateString
	collectionId: string
	collectionName: Collections
	expand?: { [key: string]: any }
}

export type AuthSystemFields = {
	email: string
	emailVisibility: boolean
	username: string
	verified: boolean
} & BaseSystemFields

// Record types for each collection

export type ImagesRecord = {
	file?: string
}

export type PostsRecord = {
	title: string
	slug: string
	body: string
	blogSummary?: string
	featuredImage?: RecordIdString
	prompt?: string
	userid?: RecordIdString
	tags?: RecordIdString[]
}

export type SubpostRecord = {
	title: string
	content: string
	post: RecordIdString
	slug: string
}

export type TagsRecord = {
	title: string
}

export type UsersRecord = {
	name?: string
	avatar?: string
}

// Response types include system fields and match responses from the PocketBase API
export type ImagesResponse = ImagesRecord & BaseSystemFields
export type PostsResponse = PostsRecord & BaseSystemFields
export type SubpostResponse = SubpostRecord & BaseSystemFields
export type TagsResponse = TagsRecord & BaseSystemFields
export type UsersResponse = UsersRecord & AuthSystemFields

export type CollectionRecords = {
	images: ImagesRecord
	posts: PostsRecord
	subpost: SubpostRecord
	tags: TagsRecord
	users: UsersRecord
}

Path: D:\Modible\Software\pocketbase-sveltekit-starter\sk\src\lib\pocketbase\ImgModal.svelte
Contents:
<script lang="ts">
import type { Record } from "pocketbase";
import { client } from ".";
import Dialog from "$lib/components/Dialog.svelte";

export let record: Record;
export let filename: string;
export let thumbOnly = false;
</script>

{#if record && filename}
  {#await client.getFileUrl(record, filename, { thumb: "100x100" }) then src}
    <Dialog>
      <img src={src} alt="todo" slot="trigger" class="thumbnail" />
      {#if !thumbOnly}
        {#await client.getFileUrl(record, filename) then src}
          <img src={src} alt="todo" />
        {/await}
      {/if}
    </Dialog>
  {/await}
{/if}

<style lang="scss">
.thumbnail {
  cursor: pointer;
  border-radius: 5px;
  box-shadow: //
    0 0 5px 0px black;
}
</style>


Path: D:\Modible\Software\pocketbase-sveltekit-starter\sk\src\lib\pocketbase\index.ts
Contents:
import PocketBase, {
  ListResult,
  Record as PBRecord,
  type AuthProviderInfo,
  RecordService,
} from "pocketbase";
import type { Admin } from "pocketbase";
import { readable, type Readable, type Subscriber } from "svelte/store";
import { browser } from "$app/environment";
import { base } from "$app/paths";
import { invalidateAll } from "$app/navigation";

export const client = new PocketBase(
  browser ? window.location.origin + "/" + base : undefined
);

export const authModel = readable<PBRecord | Admin | null>(
  null,
  function (set) {
    client.authStore.onChange((token, model) => {
      set(model);
      invalidateAll(); // re-run load functions for current page
    }, true);
  }
);

export async function login(
  email: string,
  password: string,
  register = false,
  rest: { [key: string]: any } = {}
) {
  if (register) {
    const user = { ...rest, email, password, confirmPassword: password };
    await client.collection("users").create(user);
  }
  await client.collection("users").authWithPassword(email, password);
}

export function logout() {
  client.authStore.clear();
}

/*
 * Save (create/update) a record (a plain object). Automatically converts to
 * FormData if needed.
 */
export async function save(collection: string, record: any, create = false) {
  // convert obj to FormData in case one of the fields is instanceof FileList
  const data = object2formdata(record);
  if (record.id && !create) {
    // "create" flag overrides update
    return await client.collection(collection).update(record.id, data);
  } else {
    return await client.collection(collection).create(data);
  }
}

export async function savePostWithTags(
  collection: string,
  record: any,
  create = false
) {
  // Separate tags from the main record data
  const { tags: tagsStr, ...postData } = record;
  const tags = tagsStr
    .split(",")
    .map((tag: string) => tag.trim())
    .filter((tag: any) => tag);

  // Save the post data first
  const postResult = await save(collection, postData, create);
  const postId = create ? postResult.id : record.id; // Assuming the ID is returned for new records

  // Now handle the tags
  await processTags(tags, postId);

  return postResult;
}

async function processTags(tags: string[], postId: string) {
  for (const tagName of tags) {
    let tagRecord = await findOrCreateTag(tagName);
    await linkTagToPost(tagRecord.id, postId);
  }
}

async function findOrCreateTag(tagName: string): Promise<PBRecord> {
  // Implement the logic to find a tag by name or create it if it doesn't exist
  // This is a placeholder function
  return new PBRecord();
}

async function linkTagToPost(tagId: string, postId: string) {
  // Implement the logic to create a record in the `taggings` collection linking the tag to the post
  // This is a placeholder function
}

// convert obj to FormData in case one of the fields is instanceof FileList
function object2formdata(obj: {}) {
  // check if any field's value is an instanceof FileList
  if (
    !Object.values(obj).some(
      (val) => val instanceof FileList || val instanceof File
    )
  ) {
    // if not, just return the original object
    return obj;
  }
  // otherwise, build FormData (multipart/form-data) from obj
  const fd = new FormData();
  for (const [key, val] of Object.entries(obj)) {
    if (val instanceof FileList) {
      for (const file of val) {
        fd.append(key, file);
      }
    } else if (val instanceof File) {
      // handle File before "object" so that it doesn't get serialized as JSON
      fd.append(key, val);
    } else if (Array.isArray(val)) {
      // for some reason, multipart/form-data wants arrays to be comma-separated strings
      fd.append(key, val.join(","));
    } else if (typeof val === "object") {
      fd.append(key, JSON.stringify(val));
    } else {
      fd.append(key, val as any);
    }
  }
  return fd;
}

export interface PageStore<T = any> extends Readable<ListResult<T>> {
  [x: string]: any;
  setPage(newpage: number): Promise<void>;
  next(): Promise<void>;
  prev(): Promise<void>;
}

export function watch<T>(
  idOrName: string,
  queryParams = {} as any,
  page = 1,
  perPage = 20,
  realtime = browser
): PageStore<T> {
  const collection = client.collection(idOrName);
  let result = new ListResult(page, perPage, 0, 0, [] as T[]);
  let set: Subscriber<ListResult<T>>;
  const store = readable<ListResult<T>>(result, (_set) => {
    set = _set;
    // fetch first page
    collection
      .getList(page, perPage, queryParams)
      .then((r) => set((result = r as ListResult<T>)));
    // watch for changes (only if you're in the browser)
    if (realtime)
      collection.subscribe("*", ({ action, record }) => {
        (async function (action: string) {
          // see https://github.com/pocketbase/pocketbase/discussions/505
          async function expand(expand: any, record: any) {
            return expand
              ? await collection.getOne(record.id, { expand })
              : record;
          }
          switch (action) {
            case "update":
              record = await expand(queryParams.expand, record);
              return result.items.map((item) =>
                (item as { id: string }).id === record.id ? record : item
              );
            case "create":
              record = await expand(queryParams.expand, record);
              const index = result.items.findIndex((item: any) => item.id === record.id);
              // replace existing if found, otherwise append
              if (index >= 0) {
                result.items[index] = record as T;
              } else {
                result.items.push(record as T);
              }
              // The 'else' block is not needed because the 'if' block above always returns
              // Append the new record to the result items array
              result.items.push(record as T);
              break; // Use 'break' to exit the switch case after adding the item
            case "delete":
              // Filter out the deleted record from the result items array
              result.items = result.items.filter((item) => (item as any).id !== record.id);
              break; // Use 'break' to exit the switch case after filtering the item
          }
          return result.items;
        })(action).then((items) =>
          set((result = { ...result, items } as ListResult<T>))
        );
      });
  });
  async function setPage(newpage: number) {
    const { page, totalPages, perPage } = result;
    if (page > 0 && page <= totalPages) {
      set((result = await collection.getList(newpage, perPage, queryParams)));
    }
  }
  return {
    ...store,
    setPage,
    async next() {
      setPage(result.page + 1);
    },
    async prev() {
      setPage(result.page - 1);
    },
  };
}

export async function providerLogin(
  provider: AuthProviderInfo,
  authCollection: RecordService
) {
  const authResponse = await authCollection.authWithOAuth2({
    provider: provider.name,
    createData: {
      // emailVisibility: true,
    },
  });
  // update user "record" if "meta" has info it doesn't have
  const { meta, record } = authResponse;
  let changes = {} as { [key: string]: any };
  if (!record.name && meta?.name) {
    changes.name = meta.name;
  }
  if (!record.avatar && meta?.avatarUrl) {
    const response = await fetch(meta.avatarUrl);
    if (response.ok) {
      const type = response.headers.get("content-type") ?? "image/jpeg";
      changes.avatar = new File([await response.blob()], "avatar", { type });
    }
  }
  if (Object.keys(changes).length) {
    authResponse.record = await save(authCollection.collectionIdOrName, {
      ...record,
      ...changes,
    });
  }
  return authResponse;
}


Path: D:\Modible\Software\pocketbase-sveltekit-starter\sk\src\lib\pocketbase\Paginator.svelte
Contents:
<script lang="ts">
import type { PageStore } from ".";

export let store: PageStore;
export let showIfSinglePage = false;
</script>

{#if showIfSinglePage || $store.totalPages > 1}
  <div class="paginator">
    <button
      type="button"
      on:click={() => store.prev()}
      disabled={$store.page <= 1}>&laquo;</button
    >
    <div>page {$store.page} of {$store.totalPages}</div>
    <button
      type="button"
      on:click={() => store.next()}
      disabled={$store.page >= $store.totalPages}>&raquo;</button
    >
  </div>
{/if}

<style lang="scss">
.paginator {
  display: flex;
  align-items: center;
  gap: 1rem;
  margin: auto;
}
</style>


Path: D:\Modible\Software\pocketbase-sveltekit-starter\sk\src\lib\pocketbase\pocketbase-types.ts
Contents:
/**
 * This file was @generated using pocketbase-typegen
 */

export enum Collections {
  Hooks = "hooks",
  Posts = "posts",
  Users = "users",
}

// Alias types for improved usability
export type IsoDateString = string;
export type RecordIdString = string;
export type HTMLString = string;

// System fields
export type BaseSystemFields<T = never> = {
  id: RecordIdString;
  created: IsoDateString;
  updated: IsoDateString;
  collectionId: string;
  collectionName: Collections;
  expand?: T;
};

export type AuthSystemFields<T = never> = {
  email: string;
  emailVisibility: boolean;
  username: string;
  verified: boolean;
} & BaseSystemFields<T>;

// Record types for each collection

export enum HooksEventOptions {
  "insert" = "insert",
  "update" = "update",
  "delete" = "delete",
}

export enum HooksActionTypeOptions {
  "command" = "command",
  "post" = "post",
}
export type HooksRecord = {
  collection: string;
  event: HooksEventOptions;
  action_type: HooksActionTypeOptions;
  action: string;
  action_params?: string;
  expands?: string;
  disabled?: boolean;
};

export type PostsRecord = {
  title: string;
  featuredImage?: string;
  body: string;
  slug: string;
  files?: string[];
  tags?: string;
  userid?: RecordIdString;
  prompt?: string;
  blogSummary?: string;
};

export type UsersRecord = {
  name?: string;
  avatar?: string;
};

// Response types include system fields and match responses from the PocketBase API
export type HooksResponse = HooksRecord & BaseSystemFields;
export type PostsResponse = PostsRecord & BaseSystemFields;
export type UsersResponse = UsersRecord & AuthSystemFields;

// Types containing all Records and Responses, useful for creating typing helper functions

export type CollectionRecords = {
  hooks: HooksRecord;
  posts: PostsRecord;
  users: UsersRecord;
};

export type CollectionResponses = {
  hooks: HooksResponse;
  posts: PostsResponse;
  users: UsersResponse;
};


Path: D:\Modible\Software\pocketbase-sveltekit-starter\sk\src\lib\pocketbase\ui.ts
Contents:
import { alerts } from "$lib/components/Alerts.svelte";

// wrapper to execute a pocketbase client request and generate alerts on failure
export async function alertOnFailure(request: () => void) {
  try {
    await request();
  } catch (e: any) {
    const {
      message,
      data: { data = {} },
    } = e;
    if (message) alerts.error(message);
    for (const key in data) {
      const { message } = data[key];
      if (message) alerts.error(`${key}: ${message}`);
    }
  }
}


Path: D:\Modible\Software\pocketbase-sveltekit-starter\sk\src\lib\services\generateBlog.ts
Contents:
import { goto } from "$app/navigation";
import { authModel, client, save } from "$lib/pocketbase";
import { metadata } from "$lib/app/stores";
import type {
  PostsResponse,
  SubpostRecord,
} from "$lib/pocketbase/generated-types";
import { ensureTagsExist, generateImageFromDreamStudio } from "$lib/utils/api";
import { alertOnFailure } from "$lib/pocketbase/ui";
import {
  promptFormat,
  titlePrompt,
  tagPrompt,
  blogSummaryPrompt,
  imagePrompt,
  blogResponsePrompt,
  tagTreePrompt,
} from "$lib/utils/prompts";
import { serviceModelSelectionStore } from "$lib/app/stores";
import { get } from "svelte/store";
import { availableServices } from "$lib/utils/api";
import { createPost } from "$lib/services/postService";

// Define the structure of the post data
interface PostData {
  title: string;
  slug: string;
  body: string;
  blogSummary: string;
  featuredImage: string;
  prompt: string;
  userid: string;
  tags: string[];
}

// Define the structure for the service and model selection
export interface ServiceModelSelection {
  selectedService: string;
  selectedModel: string;
}

// Function to call the API
async function callAPI(
  selectedService: string,
  selectedModel: string,
  inputText: string
): Promise<string> {
  if (!selectedService || !selectedModel) {
    console.log("Selected service: ", selectedService);
    console.log("Selected model: ", selectedModel);

    // Select the first service and first model as default
    const defaultService = availableServices[0];
    selectedService = defaultService.name;
    selectedModel = defaultService.models[0];

    console.log("Default service selected: ", selectedService);
    console.log("Default model selected: ", selectedModel);
  }

  const response = await fetch(`/api/${selectedService.toLowerCase()}`, {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({ text: inputText, model: selectedModel }),
  });

  if (!response.ok) {
    throw new Error("Network response was not ok");
  }

  const data = await response.json();
  return data.result;
}

// Main function to generate and save the blog post
export async function generateBlog(
  userInput: string,
  engineId: string,
  authModel: any
): Promise<void> {
  /* if (!authModel?.id) {
    console.error("User is not logged in.");
    alert("Please log in to save your post.");
    return;
  } */

  let post: PostData = {
    title: "",
    slug: "",
    body: "",
    blogSummary: "",
    featuredImage: "",
    prompt: "",
    userid: authModel.id,
    tags: [],
  };

  try {
    const { selectedService, selectedModel } = get(serviceModelSelectionStore);

    // Generate content
    post.body = await callAPI(
      selectedService,
      selectedModel,
      `${promptFormat}'${userInput}'`
    );
    post.title = await callAPI(
      selectedService,
      selectedModel,
      `${titlePrompt}'${post.body}'`
    );
    const tagString = await callAPI(
      selectedService,
      selectedModel,
      `${tagPrompt}'${post.body}'`
    );
    post.blogSummary = await callAPI(
      selectedService,
      selectedModel,
      `${blogSummaryPrompt}'${post.body}'`
    );

    // Generate slug
    post.slug = post.title
      .toLowerCase()
      .replace(/\s+/g, "-")
      .replace(/[^\w-]+/g, "")
      .substring(0, 50);
    post.prompt = userInput;

    // Save tags
    const tagsArray = tagString
      .split(",")
      .map((tag) => tag.trim())
      .filter((tag) => tag);
    const tagIds = await ensureTagsExist(tagsArray);
    post.tags = tagIds;

    // Generate image
    const imageResponseText = await callAPI(
      selectedService,
      selectedModel,
      `${imagePrompt}'${post.body}'`
    );
    
    // Create the post using the createPost function from postsService
    const createdPost = await createPost(post as Partial<PostsResponse>, imageResponseText, engineId);


    if (createdPost !== undefined) {
      // Redirect to the newly created post
      goto(
        `${import.meta.env.VITE_APP_SK_URL}/posts/${
          (createdPost as PostsResponse).slug
        }/inspire`
      );
    } else {
      throw new Error("Failed to create the post.");
    }
  } catch (error) {
    alertOnFailure(() => `Failed to generate and save post: ${error}`);
    throw error;
  }
}

function isBase64Image(str: string) {
  const base64ImagePattern =
    /^data:image\/(?:png|jpeg|gif);base64,(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/;
  return base64ImagePattern.test(str);
}

// Main function to generate and save the blog response (subpost)
export async function generateBlogResponse(
  userInput: string,
  parentPostId: string,
  authModel: any
): Promise<void> {
  /* if (!authModel?.id) {
    console.error("User is not logged in.");
    alert("Please log in to save your subpost.");
    return;
  } */

  let subpost: SubpostRecord = {
    title: "",
    content: "",
    post: parentPostId,
    slug: "",
  };

  try {
    const { selectedService, selectedModel } = get(serviceModelSelectionStore);

    // Generate content and title concurrently
    const [content, title] = await Promise.all([
      callAPI(
        selectedService,
        selectedModel,
        `${blogResponsePrompt} + "  " + '${userInput}'`
      ),
      callAPI(selectedService, selectedModel, `${titlePrompt}'${userInput}'`),
    ]);
    // Generate slug
    subpost.slug = title
      .toLowerCase()
      .replace(/\s+/g, "-")
      .replace(/[^\w-]+/g, "")
      .substring(0, 50);

    subpost.content = content;
    subpost.title = title;
    // Create the subpost
    await save("subpost", subpost as SubpostRecord, true);

    // Redirect to the parent post
    const parentPost = await client.collection("posts").getOne(parentPostId);
    goto(`${import.meta.env.VITE_APP_SK_URL}/posts/${parentPost.slug}`);
  } catch (error) {
    alertOnFailure(() => `Failed to generate and save subpost: ${error}`);
    throw error;
  }
}

export async function generateTagTree(
  tags: string,
  authModel: any
): Promise<string> {
  try {
    let tempName = availableServices[1].name;
    let tempMode = availableServices[1].models[1];

    const {} = get(serviceModelSelectionStore);

    // Generate content
    const [rawTagTree] = await Promise.all([
      await callAPI(tempName, tempMode, `${tagTreePrompt}'${tags}'`),
    ]);

    // Clean the generated tagTree
    //const cleanedTagTree = cleanTagTree(rawTagTree);

    // Parse the cleaned tagTree as JSON
    //const parsedTagTree = JSON.parse(cleanedTagTree);
    return rawTagTree;
  } catch (error) {
    alertOnFailure(() => `Failed to generate and save post: ${error}`);
    throw error;
  }
}

function cleanTagTree(rawTagTree: string): string {
  // Remove intro and exit text
  const cleanedTagTree = rawTagTree
    .replace(/^[\s\S]*?{/, "{")
    .replace(/}[\s\S]*?$/, "}");

  // Validate and format the JSON
  try {
    console.log("cleanedTagTree: ", cleanedTagTree);
    const parsedTagTree = JSON.parse(cleanedTagTree);
    console.log("parsedTagTree: ", parsedTagTree);
    const formattedTagTree = JSON.stringify(parsedTagTree, null, 2);
    return formattedTagTree;
  } catch (error: any) {
    throw new Error(`Invalid JSON: ${error.message}`);
  }
}


Path: D:\Modible\Software\pocketbase-sveltekit-starter\sk\src\lib\services\postService.ts
Contents:
// lib/services/postsService.ts
import { client } from "$lib/pocketbase";
import { writable } from "svelte/store";
import type { PostsResponse } from "$lib/pocketbase/generated-types";

async function populateFeaturedImage(
  post: PostsResponse
): Promise<string | undefined> {
  if (post.expand?.featuredImage) {
    const image = post.expand.featuredImage;
    if (
      "file" in image &&
      "id" in image &&
      "collectionId" in image &&
      "collectionName" in image
    ) {
      try {
        return client.getFileUrl(image, image.file);
      } catch (error) {
        console.error("Error getting featured image URL:", error);
        return "https://via.placeholder.com/800x400.png?text=cool+wind"; // Set a default image URL
      }
    }
  }
  return undefined;
}

async function populateTags(post: PostsResponse): Promise<string[]> {
  if (post.expand?.tags) {
    return post.expand.tags.map((tag: { title: string }) => tag.title);
  } else if (post.tags && post.tags.length > 0) {
    const tagIds = post.tags.map((tagId) => `id = "${tagId}"`).join(" || ");
    try {
      const tags = await client
        .collection("tags")
        .getFullList(undefined, { filter: tagIds });
      return tags.map((tag) => tag.title);
    } catch (error) {
      console.error("Error fetching tags:", error);
      return []; // Return an empty array as a fallback
    }
  }
  return [];
}

async function populatePostData(post: PostsResponse): Promise<PostsResponse> {
  const featuredImage = await populateFeaturedImage(post);
  const tags = await populateTags(post);
  return { ...post, featuredImage, tags };
}

export async function fetchPosts(
  page = 1,
  perPage = 20
): Promise<{
  posts: PostsResponse[];
  page: number;
  perPage: number;
  totalPages: number;
} | null> {
  try {
    const postsResponse = await client
      .collection("posts")
      .getList<PostsResponse>(page, perPage, {
        sort: "-updated",
        expand: "featuredImage,tags",
      });

    const posts = await Promise.all(postsResponse.items.map(populatePostData));
    const postsData = {
      posts: posts,
      page: postsResponse.page,
      perPage: postsResponse.perPage,
      totalPages: postsResponse.totalPages,
    };
    postsStore.set(postsData);
    return postsData;
  } catch (error) {
    console.error("Error fetching posts:", error);
    return null; // Return null to indicate an error occurred
  }
}

export async function fetchPostBySlug(slug: string) {
  try {
    // Encode the slug to handle special characters
    const encodedSlug = encodeURIComponent(slug);

    const postsResponse = await client
      .collection("posts")
      .getFirstListItem<PostsResponse>(`slug = "${encodedSlug}"`, {
        expand: "featuredImage,tags",
      });

    const post = await populatePostData(postsResponse);
    return post;
  } catch (error) {
    console.error("Error fetching post:", error);
    throw error;
  }
}

// Refactored createPost function
export async function createPost(
  postData: Partial<PostsResponse>,
  imagePrompt: string,
  engineId: string
): Promise<PostsResponse | null> {
  try {
    // Call the new createImage function
    const imageRecordId = await createImage(imagePrompt, engineId);

    // Set the featuredImage field to the image record ID
    postData.featuredImage = imageRecordId;

    // Create the post record
    const createdPost = await client
      .collection("posts")
      .create<PostsResponse>(postData);
    const populatedPost = await populatePostData(createdPost);
    postsStore.update((store) => {
      return {
        ...store,
        posts: [...store.posts, populatedPost],
      };
    });
    return populatedPost;
  } catch (error) {
    console.error("Error creating post:", error);
    return null;
  }
}

async function createImage(imagePrompt: string, engineId: string) {
  const imageResponse = await fetch("/api/dreamstudio", {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({ prompt: imagePrompt }),
  });

  if (!imageResponse.ok) {
    throw new Error("Failed to upload image");
  }

  const imageData = await imageResponse.json();
  console.log("Image data:", imageData);
  return imageData.id;
}


export async function updatePost(
  postId: string,
  postData: Partial<PostsResponse>
): Promise<PostsResponse | null> {
  try {
    const updatedPost = await client
      .collection("posts")
      .update<PostsResponse>(postId, postData);
    const populatedPost = await populatePostData(updatedPost);
    postsStore.update((store) => {
      const index = store.posts.findIndex((post) => post.id === postId);
      if (index !== -1) {
        const updatedPosts = [...store.posts];
        updatedPosts[index] = populatedPost;
        return { ...store, posts: updatedPosts };
      }
      return store;
    });
    return populatedPost;
  } catch (error) {
    console.error("Error updating post:", error);
    return null; // Return null to indicate an error occurred
  }
}

export async function deletePost(postId: string): Promise<boolean> {
  try {
    await client.collection("posts").delete(postId);
    postsStore.update((store) => {
      return {
        ...store,
        posts: store.posts.filter((post) => post.id !== postId),
      };
    });
    return true; // Return true to indicate successful deletion
  } catch (error) {
    console.error("Error deleting post:", error);
    return false; // Return false to indicate an error occurred
  }
}

function createPostsStore() {
  const { subscribe, set, update } = writable<{
    posts: PostsResponse[];
    page: number;
    perPage: number;
    totalPages: number;
  }>({
    posts: [],
    page: 1,
    perPage: 20,
    totalPages: 1,
  });

  return {
    subscribe,
    set,
    update,
    appendPosts: (newPosts: PostsResponse[], totalPages: number) =>
      update((store) => ({
        ...store,
        posts: [...store.posts, ...newPosts],
        totalPages,
      })),
    reset: () => set({ posts: [], page: 1, perPage: 20, totalPages: 1 }),
  };
}

const postsStore = createPostsStore();
export { postsStore };


Path: D:\Modible\Software\pocketbase-sveltekit-starter\sk\src\lib\stores\postStore.ts
Contents:
// lib/stores/postsStore.ts
import { writable } from 'svelte/store';
import type { PostsResponse } from '$lib/pocketbase/generated-types';

export const postsStore = writable<PostsResponse[]>([]);

Path: D:\Modible\Software\pocketbase-sveltekit-starter\sk\src\lib\utils\api.ts
Contents:
// src/lib/utils/api.ts
// Improved error handling and abstraction of API URL and parameters

import { env } from "$env/dynamic/public";
import { client } from "$lib/pocketbase";

const engineId = "stable-diffusion-v1-6";
const apiHost = import.meta.env.VITE_STABILITY_API_HOST;

const API_BASE_URL = import.meta.env.VITE_APP_BASE_URL;
const CHATGPT_KEY = import.meta.env.VITE_CHATGPT_API_KEY;
const SD_KEY = import.meta.env.VITE_STABILITY_API_KEY;
const CLAUDE_KEY = import.meta.env.VITE_ANTHROPIC_API_KEY;
const DALLE_KEY = import.meta.env.VITE_CHATGPT_API_KEY;

//validate that keys are present
if (!API_BASE_URL) {
  throw new Error("Missing APP_BASE_URL");
}
if (!CHATGPT_KEY) {
  throw new Error("Missing CHATGPT_API_KEY");
}
if (!SD_KEY) {
  throw new Error("Missing STABILITY_API_KEY");
}
if (!CLAUDE_KEY) {
  throw new Error("Missing ANTHROPIC_API_KEY");
}
if (!DALLE_KEY) {
  throw new Error("Missing DALLE_API_KEY");
}

export const availableServices = [
  {
    name: "Anthropic",
    models: [
      "claude-3-haiku-20240307",
      "claude-3-sonnet-20240229",
      "claude-3-opus-20240229",
      "claude-2.1",
      "claude-2.0",
      "claude-instant-1.2",
    ],
  },
  {
    name: "OpenAI",
    models: ["gpt-4-turbo-preview", "gpt-3.5-turbo"],
  },
];

export async function apiRequest<T>(
  endpoint: string,
  method: "GET" | "POST" = "GET",
  body: any = null
): Promise<T> {
  const headers = { "Content-Type": "application/json" };
  const config: RequestInit = { method, headers };

  if (body) {
    config.body = JSON.stringify(body);
  }

  try {
    const response = await fetch(`${API_BASE_URL}${endpoint}`, config);
    if (!response.ok) {
      // Assuming the response includes a JSON body with an error message
      const errorBody = await response.json();
      throw new Error(
        errorBody.message || `Request failed with status ${response.status}`
      );
    }
    return await response.json();
  } catch (error) {
    // Log the error to an error reporting service if you have one
    console.error("API Request failed:", error);
    throw error;
  }
}

export async function ensureTagsExist(tags: string[]): Promise<string[]> {
  const existingTags = await client.collection("tags").getFullList({
    filter: tags.map((tag) => `title = "${tag}"`).join(" || "),
  });

  const existingTagTitles = existingTags.map((tag) => tag.title);
  const newTagTitles = tags.filter((tag) => !existingTagTitles.includes(tag));

  console.log("New tags", newTagTitles);

  client.autoCancellation(false);
  // Create new tags with retries
  const newTags = await Promise.all(
    newTagTitles.map((title) => client.collection("tags").create({ title }))
  );
  client.autoCancellation(true);

  console.log("Created new tags", newTags);

  return [...existingTags, ...newTags].map((tag) => tag.id);
}

export async function getTagsForPost(slug: string): Promise<string> {
  try {
    console.log("Fetching tags for post", slug);
    const postsResponse = await client
      .collection("posts")
      .getFirstListItem(`slug = "${slug}"`, {
        expand: "tags",
      });
    if (!postsResponse) {
      return "";
    }

    const tags =
      postsResponse.expand?.tags?.map((tag: { title: any }) => tag.title) || [];
    console.log("Tags for post", slug, tags);
    return tags.join(", ");
  } catch (error) {
    console.error("Error fetching tags:", error);
    return "";
  }
}

export async function generateTextFromClaude(prompt: string): Promise<string> {
  try {
    console.log("Generating text from Claude", prompt);
    const response = await fetch("/api/proxy/anthropic", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
      },
      body: JSON.stringify({
        human: prompt,
      }),
    });
    console.log("Response from Claude", response);

    if (!response.ok) {
      throw new Error(`HTTP error! status: ${response.status}`);
    }

    const data = await response.json();
    return data.response;
  } catch (error) {
    console.error("Error:", error);
    throw error;
  }
}

export async function generateImageFromDalle(prompt: string): Promise<string> {
  try {
    const response = await fetch(
      "https://api.openai.com/v1/images/generations",
      {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          Authorization: `Bearer ${DALLE_KEY}`,
        },
        body: JSON.stringify({
          model: "image-alpha-001",
          prompt: prompt,
          num_images: 1,
          size: "512x512",
          response_format: "url",
        }),
      }
    );
    if (!response.ok) throw new Error("Failed to generate image from Dalle");

    const data = await response.json();
    return data.data[0].url;
  } catch (error) {
    console.error("Error:", error);
    throw error;
  }
}

export async function generateImageFromDreamStudio(
  prompt: string
): Promise<string> {
  try {
    const response = await fetch(
      `https://api.stability.ai/v1/generation/${engineId}/text-to-image`,
      {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          Authorization: `Bearer ${SD_KEY}`,
        },
        body: JSON.stringify({
          text_prompts: [{ text: prompt }],
          cfg_scale: 7,
          clip_guidance_preset: "FAST_BLUE",
          height: 512,
          width: 512,
          samples: 1,
          steps: 30,
        }),
      }
    );
    console.log("Response from DreamStudio", response);
    if (!response.ok)
      throw new Error("Failed to generate image from DreamStudio");
    const data = await response.json();
    return data.artifacts[0].base64;
  } catch (error) {
    console.error("Error:", error);
    throw error;
  }
}

export async function generateTextFromChatGPT(prompt: string): Promise<string> {
  try {
    const response = await fetch("https://api.openai.com/v1/chat/completions", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        Authorization: `Bearer ${CHATGPT_KEY}`,
      },
      body: JSON.stringify({
        model: "gpt-3.5-turbo",
        messages: [{ role: "user", content: prompt }],
        max_tokens: 1024,
        n: 1,
        stop: null,
        temperature: 0.5,
        top_p: 0.5,
      }),
    });
    if (!response.ok) throw new Error("Failed to generate text from ChatGPT");
    const data = await response.json();
    return data.choices[0].message.content.trim();
  } catch (error) {
    console.error("Error:", error);
    throw error;
  }
}


Path: D:\Modible\Software\pocketbase-sveltekit-starter\sk\src\lib\utils\prompts.ts
Contents:
/* 
  export const promptFormat = `Title: Comprehensive Idea Exploration and Mind Mapping

Description: This prompt is designed to take a single phrase, idea, or concept as input and explore it in-depth across various dimensions. The goal is to generate a comprehensive, interconnected map of thoughts, questions, possibilities, and related topics to serve as a rich creative or analytical reference.

Input Instructions:
- Clearly state the phrase, idea, or concept you wish to explore.
- Provide any specific context or constraints you want the exploration to adhere to, such as a particular field of interest (e.g., technology, philosophy, art), purpose (e.g., innovation, problem-solving, education), or any specific questions you're looking to answer.
- If applicable, mention any additional perspectives or dimensions you'd like the exploration to cover.

Output Specifications:
1. **Initial Overview**: A concise summary of the core idea or concept, including its basic definition, common understanding, and any relevant domain-specific interpretations.
2. **Exploratory Questions**: A comprehensive list of thought-provoking, open-ended questions that arise from the initial idea. These questions should uncover underlying assumptions, explore potential implications, and delve into practical applications.
3. **Possibilities and Scenarios**: Detailed descriptions of diverse scenarios, applications, or manifestations of the idea across various contexts. This section should expand the horizon of the initial concept, offering innovative, unconventional, and cross-disciplinary perspectives.
4. **Related Topics and Ideas**: Identification of a wide range of closely and peripherally related topics, ideas, or concepts that could enrich or be enriched by the initial idea. This may include interdisciplinary connections, contrasting viewpoints, or complementary concepts.
5. **Actionable Insights**: Derive practical insights, recommendations, or action points based on the exploration of the idea. These should be concrete, applicable suggestions that readers can implement or further investigate.
6. **Resources for Further Exploration**: A carefully curated list of recommended readings, resources, or activities to deepen understanding and expand the exploration of the idea. This could include books, articles, podcasts, videos, courses, or interactive tools.

Example Input:
"Explore the concept of 'Artificial Intelligence' with a focus on its implications for creative industries, considering ethical considerations, future innovation opportunities, and its potential impact on the workforce."

Example Output:
1. **Initial Overview**: Artificial Intelligence (AI) refers to the simulation of human intelligence in machines... 🤖
2. **Exploratory Questions**: 
   - What are the ethical implications of AI in creative processes? 🎨🔍
   - Can AI truly replicate the emotional depth and nuance of human creativity? 🧠❓
   - How might AI augment or enhance human creativity rather than replace it? 🤝💡
   ...
3. **Possibilities and Scenarios**: 
   - In the realm of music production, AI could revolutionize the composition process by... 🎵🎹
   - AI-powered tools could assist writers in generating unique story ideas, plots, and characters... 📝✨
   ...
4. **Related Topics and Ideas**:
   - Machine Learning 🧠📊
   - Computational Creativity 🎨💻
   - Ethical AI 🤖❤️
   - Human-AI Collaboration 👥🤝🤖
   ...
5. **Actionable Insights**:
   - Creative professionals should proactively learn about AI technologies to harness their potential... 📖💡
   - Organizations must develop ethical guidelines and frameworks for the use of AI in creative industries... 📜✅
   ...
6. **Resources for Further Exploration**:
   - Book: "The Creativity Code" by Marcus du Sautoy 📚
   - TED Talk: "How AI can enhance our memory, work and social lives" by Tom Gruber 🎥
   - Online Course: "Creative Applications of Deep Learning with TensorFlow" on Kadenze 🎓
   ...

Usage Note: This prompt format can be adapted and expanded based on the complexity of the idea or concept being explored and the depth of exploration desired. 
Feel free to customize the output specifications and example to suit your specific needs. Only export blog as if it were cut/paste into a magazine. 

Do not include any intro text about the output, just respond with the blog. Use rich markdown formatting and relevant emojis to make the output visually engaging and easy to navigate. 

This is the user's inspiration: `; 

export const titlePrompt = `Craft an SEO-Optimized Title for Your Blog Post: Detailed Instructions

Accurately Reflect Content: Your title should encapsulate the blog's primary themes, insights, and conclusions, integrating relevant keywords for SEO.
Clear and Engaging: Construct a title that is both informative and enticing, offering a glimpse into the post's value and compelling readers to click.
Length and Format: Aim for a concise title of 5-7 words, keeping within 50-60 characters to ensure full visibility in search engine results. This aligns with SEO best practices for HTML page titles, maximizing impact and search rankings.
Title Case and Punctuation: Apply title case capitalization, with all principal words capitalized except for articles, prepositions, and conjunctions. Avoid ending the title with punctuation to maintain clarity and focus.
Plain Text: Present the title in plain text format, suitable for inclusion in the HTML <title> tag, enhancing both SEO and user click-through rates.

When formulating your blog article's title, follow these guidelines closely to craft a single, SEO-optimized title. Ensure it meets the specified length and character count for optimal online visibility and engagement, without adding extra text or comments.

ONLY OUTPUT THE TITLE

This is the blog: 

`;

export const tagPrompt = `Please analyze the provided blog article and generate relevant tags based on its main points and themes. The tags should:

- Consist of 5 concise, lowercase, single-word tags, can be 2 or 3 words just joined together) that capture the essence of the article
- They shoud be separated by commas, without any spaces between the commas and words
- Cover key topics, concepts, or categories mentioned in the article
- Help readers quickly identify the article's main focus areas and improve searchability
- Only use alphabets, no special characters or numbers
- Be output as plain text, strictly adhering to the specified format: 'tag1,tag2,tag3,tag4,tag5'

Example Input:
"This article discusses the importance of mindfulness in reducing stress and improving overall well-being. It explores various mindfulness techniques, such as meditation, deep breathing, and yoga, and provides practical tips for incorporating these practices into daily life."

Example Output:
mindfulness,stress,well-being,meditation,breathing

Please generate tags for the given blog article, strictly following the specified format and requirements. Output only the tags, without any additional text or formatting. This is the blog article: `;

export const blogSummaryPrompt = `Please compose a concise and engaging summary for the provided blog article, designed to accompany the article's title on a Tailwind CSS card. The summary should:

- Encapsulate the main points, themes, and value proposition of the article in 50-100 words
- Be clear, informative, and captivating, encouraging readers to click through and read the full article
- Highlight the article's unique perspective, actionable insights, or key takeaways
- Use a mix of simple and compound sentences to create a flowing, easy-to-read narrative
- Incorporate relevant emojis and markdown formatting to make the summary visually appealing and engaging
- Be output as a single paragraph of plain text, without any additional content or formatting

Example Input:
"This article delves into the world of productivity hacks, offering practical tips and strategies to help readers maximize their time and efficiency. From prioritizing tasks using the Eisenhower Matrix to leveraging the power of time-blocking and pomodoro techniques, this post provides a comprehensive guide to boosting productivity in both personal and professional life."

Example Output:
🚀 Unlock the secrets to peak productivity with this ultimate guide! 🔓📈 Discover proven techniques like the Eisenhower Matrix, time-blocking, and pomodoro to maximize your time and efficiency. 📅⏰ Whether you're looking to crush your personal goals or excel in your professional life, this article offers practical, actionable insights to help you master the art of productivity. 💪📚 Get ready to take your performance to the next level! 🎯🌟

Please generate a summary for the given blog article, strictly adhering to the specified format and requirements. Output only the summary, without any additional text or formatting. This is the blog article: `;

export const imagePrompt = `Enhanced Image Prompt Generation Guidelines:

"Analyze the provided text to create a comprehensive prompt for designing an image that not only encapsulates the text's core message but also adheres to a specific aesthetic directive. The crafted image prompt should:

Concisely depict a scene or concept that aligns with the main ideas or themes presented in the text, ensuring the visual representation is both impactful and relevant.
Clearly define a minimalist, modern style, emphasizing a sleek design with a 2-3 color monotone palette to ensure visual consistency and cohesion across images.
Detail the composition, including any critical elements or symbols that should be featured, to reinforce the text's message through visual means.
Direct the mood, emotion, or atmosphere to reflect the text's tone, using minimalistic design principles to evoke the intended feelings in the audience.
Utilize natural language to offer clear, precise instructions tailored for an artist or designer, encapsulating the request in 3-5 descriptive sentences.
The description must be delivered as plain text, focused solely on the image prompt without additional content or formatting.

Make sure to NOT include faces or hands in the image - call this out specifically!

This is the users text:`;


export const introPrompt = `You are an innovative thought generator, capable of interpreting a given phrase or idea from five distinct perspectives. When presented with a concept, your task is to rephrase it into five unique ideas, each embodying a different viewpoint:

1. 🌞 Optimistic: Consistently sees the bright side and envisions the most favorable outcomes.
2. 🌧️ Pessimistic: Tends to focus on the negative aspects and anticipates potential drawbacks.
3. 🧐 Realistic: Assesses situations objectively, basing decisions on facts and practicality.
4. 🎨 Creative: Approaches challenges with originality, thinking innovatively to generate novel ideas.
5. 🔍 Analytical: Methodically deconstructs issues to identify underlying causes and patterns.

For each perspective, generate a thought-provoking interpretation of the original concept, offering a deeper understanding of the idea through the lens of that particular mindset.

Please format your response as follows, using only plain text without any additional separators or formatting (seperate each interpretation with a new line):

Optimistic: [Optimistic interpretation]
Pessimistic: [Pessimistic interpretation] 
Realistic: [Realistic interpretation]
Creative: [Creative interpretation]
Analytical: [Analytical interpretation]

Example Input:
"The impact of social media on personal relationships and communication"

Example Output:
Optimistic: Social media has the power to strengthen connections, fostering deeper relationships and enabling people to stay in touch across vast distances.
Pessimistic: Social media is eroding the quality of personal interactions, leading to superficial relationships and a growing sense of isolation and disconnection.
Realistic: Social media is a tool that can facilitate or hinder personal relationships, depending on how it is used and the individual's ability to balance online and offline communication.
Creative: Social media is transforming the landscape of human interaction, giving rise to new forms of self-expression, collaboration, and community-building that transcend traditional boundaries.
Analytical: The impact of social media on personal relationships is complex and multifaceted, influenced by factors such as platform design, user behavior, and societal norms, requiring ongoing research and analysis to fully understand its implications.

ONLY RESPOND WITH THE FIVE INTERPRETATIONS, NO ADDITIONAL TEXT OR FORMATTING.

Please provide your five perspectives on the following concept:`; */

export const promptFormat = `You will accept an input ranging from a single word to a complete article and explore it in-depth across various dimensions. The goal is to generate a comprehensive, interconnected map of thoughts, questions, possibilities, and related topics organized into bullet points. These bullet points will serve as "seed" information that the user can later select from to generate more detailed articles.

Input Instructions:
- Provide the word, phrase, idea, concept, or article you wish to explore.
- Specify any specific context or constraints you want the exploration to adhere to, such as a particular field of interest (e.g., technology, philosophy, art), purpose (e.g., innovation, problem-solving, education), or any specific questions you're looking to answer.
- If applicable, mention any additional perspectives or dimensions you'd like the exploration to cover.

Output Specifications:
1. **Initial Overview**: A concise summary of the core idea or concept, including its basic definition, common understanding, and any relevant domain-specific interpretations.
2. **Exploratory Questions**: A list of thought-provoking, open-ended questions that arise from the initial idea. These questions should uncover underlying assumptions, explore potential implications, and delve into practical applications.
3. **Possibilities and Scenarios**: Descriptions of diverse scenarios, applications, or manifestations of the idea across various contexts. This section should expand the horizon of the initial concept, offering innovative, unconventional, and cross-disciplinary perspectives.
4. **Related Topics and Ideas**: Identification of a wide range of closely and peripherally related topics, ideas, or concepts that could enrich or be enriched by the initial idea. This may include interdisciplinary connections, contrasting viewpoints, or complementary concepts.
5. **Actionable Insights**: Derive practical insights, recommendations, or action points based on the exploration of the idea. These should be concrete, applicable suggestions that readers can implement or further investigate.
6. **Resources for Further Exploration**: A curated list of recommended readings, resources, or activities to deepen understanding and expand the exploration of the idea. This could include books, articles, podcasts, videos, courses, or interactive tools.

Please organize the output into relevant bullet points under each of the specified sections. These bullet points will be used as "seed" information for generating more detailed articles later.

Do not include any intro text about the output, just respond with the mind map organized into bullet points. Use markdown formatting to make the output easy to navigate. 

This is the user's input: `;

export const tagTreePrompt = `
Task: Generate a hierarchical tag structure from a given list of tags

Input:
- A list of tags as strings in an array

Output:
[
  {
    "name": "Node 1",
    "children": [
      {
        "name": "Child 1",
        "children": [
          {
            "name": "Grandchild 1"
          },
          {
            "name": "Grandchild 2"
          }
        ]
      },
      {
        "name": "Child 2"
      }
    ]
  },
  {
    "name": "Node 2",
    "children": [
      {
        "name": "Child 3"
      },
      {
        "name": "Child 4"
      }
    ]
  }
]

Rules:
1. The hierarchical tag structure should have a maximum depth of 5 levels.
2. Each node in the hierarchy should have at most 5 children.
3. The top 3-5 levels of the hierarchy can be AI-generated headings to categorize the tags.
4. The given tags should be used to complete the lower levels of the hierarchy.
5. Related tags should be grouped together under appropriate parent nodes.
6. The hierarchy should be designed to allow users to easily navigate and discover blogs based on the tags.
7. Broader terms should be placed higher in the hierarchy, while more specific terms should be placed lower.
8. If there are any tags that don't fit into the generated categories, they should be placed under an "Others" or "Uncategorized" node.
9. The output should be a valid JSON object in the specified format.

Steps:
1. Analyze the given list of tags and identify common themes or categories.
2. Generate 3-5 levels of AI-generated headings to categorize the tags based on their themes or categories.
3. Assign the tags to appropriate parent nodes in the hierarchy, ensuring that no node has more than 5 children.
4. Place broader terms higher in the hierarchy and more specific terms lower.
5. Group related tags together under the same parent node.
6. If there are any tags that don't fit into the generated categories, create an "Others" or "Uncategorized" node and place them there.
7. Review the generated hierarchy to ensure it allows for easy navigation and discovery of blogs based on the tags.
8. Output the hierarchical tag structure as a valid JSON object in the specified format.

Example input:
[
  "ai",
  "machine-learning",
  "deep-learning",
  "natural-language-processing",
  "robotics",
  "computer-vision",
  "blockchain",
  "cryptocurrency",
  "web3",
  "smart-contracts",
  "decentralized-finance",
  "health",
  "fitness",
  "nutrition",
  "mental-health",
  "productivity",
  "time-management",
  "goal-setting",
  "motivation",
  "leadership"
]

Please generate the hierarchical tag structure for the given list of tags, following the specified format and rules. 

DO NOT INCLUDE ANY INTRODUCTORY TEXT, JUST RESPOND WITH THE JSON OBJECT.

This is the list of tags: `;

export const blogResponsePrompt = `
###Instruction###
Given a list of key topics, questions, and ideas provided below, generate a detailed and comprehensive blog post. The blog post should:
1. Introduce the main theme based on the provided list.
2. Address each point in the list by providing in-depth analysis, context, or explanation as relevant.
3. Expand on the provided points with additional information, insights, or examples to create a full narrative.
4. Ensure the blog is structured logically, with a clear introduction, body (covering all provided points), and conclusion.
5. Write in an engaging and informative tone, suitable for readers who may be new to the subject or looking to deepen their understanding.

###Input Text###
- [User-provided list of phrases, questions, and ideas seperated by '/n']

Please parse the input text to identify the key topics and structure the blog post accordingly.
This is the input text:  
`;

export const titlePrompt = `Your job is to craft an SEO-Optimized title for the provided blog post. The title should be concise, engaging, and accurately reflect the content of the blog. Follow the guidelines below to create an effective title:

Accurately Reflect Content: Your title should encapsulate the blog's primary themes, insights, and conclusions, integrating relevant keywords for SEO.
Clear and Engaging: Construct a title that is both informative and enticing, offering a glimpse into the post's value and compelling readers to click.
Length and Format: Aim for a concise title of 5-7 words, keeping within 50-60 characters to ensure full visibility in search engine results. This aligns with SEO best practices for HTML page titles, maximizing impact and search rankings.
Title Case and Punctuation: Apply title case capitalization, with all principal words capitalized except for articles, prepositions, and conjunctions. Avoid ending the title with punctuation to maintain clarity and focus.
Plain Text: Present the title in plain text format, suitable for inclusion in the HTML <title> tag, enhancing both SEO and user click-through rates.

When formulating your blog article's title, follow these guidelines closely to craft a single, SEO-optimized title. Ensure it meets the specified length and character count for optimal online visibility and engagement, without adding extra text or comments.

No apostrophes, No parentheses, or special characters in the title.
Must be 50 - 60 total characters long.
ONLY OUTPUT THE TITLE

This is the blog: 

`;

export const tagPrompt = `Please analyze the provided blog article and generate relevant tags based on its main points and themes. The tags should:

- Generate of 3 concise, lowercase tags (can be 2 words joined together) that capture the essence of the article
- They should be separated by commas, without any spaces between the commas and words
- Cover key topics, concepts, or categories mentioned in the article
- Help readers quickly identify the article's main focus areas and improve searchability
- Only use alphabets, no special characters or numbers
- Output as plain text, strictly adhering to the specified format: 'tag1,tag2,tag3'

Example Input:
"This article discusses the importance of mindfulness in reducing stress and improving overall well-being. It explores various mindfulness techniques, such as meditation, deep breathing, and yoga, and provides practical tips for incorporating these practices into daily life."

Example Output:
mindfulness,stress,wellbeing

Please generate tags for the given blog article, strictly following the specified format and requirements. Output only the tags, without any additional text or formatting. This is the blog article: `;

export const blogSummaryPrompt = `Please compose a concise and engaging summary for the provided blog article, designed to accompany the article's title on a Tailwind CSS card. The summary should:

- Encapsulate the main points, themes, and value proposition of the article in 50 words or less
- Be clear, informative, and captivating, encouraging readers to click through and read the full article
- Highlight the article's unique perspective, actionable insights, or key takeaways
- Use a mix of simple and compound sentences to create a flowing, easy-to-read narrative
- Incorporate relevant emojis and markdown formatting to make the summary visually appealing and engaging
- Be output as a single paragraph of plain text, without any additional content or formatting

Example Input:
"This article delves into the world of productivity hacks, offering practical tips and strategies to help readers maximize their time and efficiency. From prioritizing tasks using the Eisenhower Matrix to leveraging the power of time-blocking and pomodoro techniques, this post provides a comprehensive guide to boosting productivity in both personal and professional life."

Example Output:
🚀 Unlock the secrets to peak productivity with this ultimate guide! 🔓📈 Discover proven techniques like the Eisenhower Matrix, time-blocking, and pomodoro to maximize your time and efficiency. 💪📚 Get ready to take your performance to the next level! 🎯🌟

Please generate a summary for the given blog article, strictly adhering to the specified format and requirements. Output only the summary, without any additional text or formatting. This is the blog article: `;

export const imagePrompt = `Enhanced Image Prompt Generation Guidelines:

"Analyze the provided text to create a comprehensive prompt for designing an image that not only encapsulates the text's core message but also adheres to a specific aesthetic directive. The crafted image prompt should:

Concisely depict a scene or concept that aligns with the main ideas or themes presented in the text, ensuring the visual representation is both impactful and relevant.
Clearly define a minimalist, modern style, emphasizing a sleek design with a 2-3 color monotone palette to ensure visual consistency and cohesion across images.
Detail the composition, including any critical elements or symbols that should be featured, to reinforce the text's message through visual means.
Direct the mood, emotion, or atmosphere to reflect the text's tone, using minimalistic design principles to evoke the intended feelings in the audience.
Utilize natural language to offer clear, precise instructions tailored for an artist or designer, encapsulating the request in 3-5 descriptive sentences.
Explicitly state that the image should not include any faces or hands.
The description must be delivered as plain text, focused solely on the image prompt without additional content or formatting.

This is the user's text:`;

export const introPrompt = `You are an innovative thought generator, capable of interpreting a given phrase or idea from six distinct perspectives. When presented with a concept, your task is to rephrase it into six unique ideas, each embodying a different viewpoint:

1. 🌞 Optimistic: Consistently sees the bright side and envisions the most favorable outcomes.
2. 🌧️ Pessimistic: Tends to focus on the negative aspects and anticipates potential drawbacks.
3. 🧐 Realistic: Assesses situations objectively, basing decisions on facts and practicality.
4. 🎨 Creative: Approaches challenges with originality, thinking innovatively to generate novel ideas.
5. 🔍 Analytical: Methodically deconstructs issues to identify underlying causes and patterns.
6. 😈 Devil's Advocate: Considers the other viewpoints and looks for alternate combinations or perspectives that challenge the prevailing ideas.

For each perspective, generate a thought-provoking interpretation of the original concept, offering a deeper understanding of the idea through the lens of that particular mindset.

Please format your response as follows, using only plain text without any additional separators or formatting (separate each interpretation with a new line):

Optimistic: [Optimistic interpretation]
Pessimistic: [Pessimistic interpretation] 
Realistic: [Realistic interpretation]
Creative: [Creative interpretation]
Analytical: [Analytical interpretation]
Devil's Advocate: [Devil's Advocate interpretation]

Example Input:
"The impact of social media on personal relationships and communication"

Example Output:
Optimistic: Social media has the power to strengthen connections, fostering deeper relationships and enabling people to stay in touch across vast distances.
Pessimistic: Social media is eroding the quality of personal interactions, leading to superficial relationships and a growing sense of isolation and disconnection.
Realistic: Social media is a tool that can facilitate or hinder personal relationships, depending on how it is used and the individual's ability to balance online and offline communication.
Creative: Social media is transforming the landscape of human interaction, giving rise to new forms of self-expression, collaboration, and community-building that transcend traditional boundaries.
Analytical: The impact of social media on personal relationships is complex and multifaceted, influenced by factors such as platform design, user behavior, and societal norms, requiring ongoing research and analysis to fully understand its implications.
Devil's Advocate: While social media can connect people, it may also create echo chambers that reinforce existing beliefs and limit exposure to diverse perspectives, potentially leading to increased polarization and conflict in personal relationships.

ONLY RESPOND WITH THE SIX INTERPRETATIONS, NO ADDITIONAL TEXT OR FORMATTING.

Please provide your six perspectives on the following concept:`;


Path: D:\Modible\Software\pocketbase-sveltekit-starter\sk\src\lib\utils\themes.ts
Contents:
export const themes = [
    {
      id: "light",
      name: "Light",
      backgroundColor: "#ffffff",
      textColor: "#000000",
      primaryColor: "#f0f0f0",
      secondaryColor: "#e0e0e0",
      accentColor: "#d0d0d0"
    },
    {
      id: "dark",
      name: "Dark",
      backgroundColor: "#000000",
      textColor: "#ffffff",
      primaryColor: "#111111",
      secondaryColor: "#222222",
      accentColor: "#333333"
    },
    {
      id: "cupcake",
      name: "Cupcake",
      backgroundColor: "#f8e5e5",
      textColor: "#8b5e34",
      primaryColor: "#f4c7c7",
      secondaryColor: "#e6b8b8",
      accentColor: "#d9a3a3"
    },
    {
      id: "bumblebee",
      name: "Bumblebee",
      backgroundColor: "#fef3c7",
      textColor: "#78350f",
      primaryColor: "#fde68a",
      secondaryColor: "#fcd34d",
      accentColor: "#fbbf24"
    },
    {
      id: "emerald",
      name: "Emerald",
      backgroundColor: "#ecfdf5",
      textColor: "#064e3b",
      primaryColor: "#d1fae5",
      secondaryColor: "#a7f3d0",
      accentColor: "#6ee7b7"
    },
    {
      id: "corporate",
      name: "Corporate",
      backgroundColor: "#ffffff",
      textColor: "#1f2937",
      primaryColor: "#e5e7eb",
      secondaryColor: "#d1d5db",
      accentColor: "#9ca3af"
    },
    {
      id: "synthwave",
      name: "Synthwave",
      backgroundColor: "#2b213a",
      textColor: "#e2e2e2",
      primaryColor: "#302b63",
      secondaryColor: "#4a00e0",
      accentColor: "#8e2de2"
    },
    {
      id: "retro",
      name: "Retro",
      backgroundColor: "#fffbeb",
      textColor: "#3f2a22",
      primaryColor: "#fde68a",
      secondaryColor: "#fcd34d",
      accentColor: "#fbbf24"
    },
    {
      id: "cyberpunk",
      name: "Cyberpunk",
      backgroundColor: "#0f0f0f",
      textColor: "#f1f1f1",
      primaryColor: "#ff7a18",
      secondaryColor: "#fe640b",
      accentColor: "#fd7e14"
    },
    {
      id: "valentine",
      name: "Valentine",
      backgroundColor: "#fce7f3",
      textColor: "#831843",
      primaryColor: "#fbcfe8",
      secondaryColor: "#f9a8d4",
      accentColor: "#f472b6"
    },
    {
      id: "halloween",
      name: "Halloween",
      backgroundColor: "#0f172a",
      textColor: "#f8fafc",
      primaryColor: "#1e293b",
      secondaryColor: "#334155",
      accentColor: "#4b5563"
    },
    {
      id: "garden",
      name: "Garden",
      backgroundColor: "#ecfccb",
      textColor: "#365314",
      primaryColor: "#d9f99d",
      secondaryColor: "#bef264",
      accentColor: "#a3e635"
    },
    {
      id: "forest",
      name: "Forest",
      backgroundColor: "#1a202c",
      textColor: "#f5f5f4",
      primaryColor: "#2d3748",
      secondaryColor: "#4a5568",
      accentColor: "#718096"
    },
    {
      id: "aqua",
      name: "Aqua",
      backgroundColor: "#e6fffa",
      textColor: "#0d5553",
      primaryColor: "#b2f5ea",
      secondaryColor: "#81e6d9",
      accentColor: "#4fd1c5"
    },
    {
      id: "lofi",
      name: "Lo-Fi",
      backgroundColor: "#f9fafb",
      textColor: "#1f2937",
      primaryColor: "#e5e7eb",
      secondaryColor: "#d1d5db",
      accentColor: "#9ca3af"
    },
    {
      id: "pastel",
      name: "Pastel",
      backgroundColor: "#fdf2f8",
      textColor: "#701a75",
      primaryColor: "#f5d0fe",
      secondaryColor: "#f0abfc",
      accentColor: "#e879f9"
    },
    {
      id: "fantasy",
      name: "Fantasy",
      backgroundColor: "#f0fdfa",
      textColor: "#075985",
      primaryColor: "#ccfbf1",
      secondaryColor: "#99f6e4",
      accentColor: "#5eead4"
    },
    {
      id: "wireframe",
      name: "Wireframe",
      backgroundColor: "#f8f8f8",
      textColor: "#333333",
      primaryColor: "#e2e2e2",
      secondaryColor: "#cccccc",
      accentColor: "#b3b3b3"
    },
    {
      id: "black",
      name: "Black",
      backgroundColor: "#000000",
      textColor: "#ffffff",
      primaryColor: "#111111",
      secondaryColor: "#222222",
      accentColor: "#333333"
    },
    {
      id: "luxury",
      name: "Luxury",
      backgroundColor: "#1a1a1a",
      textColor: "#fafafa",
      primaryColor: "#2e2e2e",
      secondaryColor: "#3b3b3b",
      accentColor: "#525252"
    },
    {
      id: "dracula",
      name: "Dracula",
      backgroundColor: "#282a36",
      textColor: "#f8f8f2",
      primaryColor: "#44475a",
      secondaryColor: "#6272a4",
      accentColor: "#bd93f9"
    },
    {
      id: "cmyk",
      name: "CMYK",
      backgroundColor: "#0f172a",
      textColor: "#f1f5f9",
      primaryColor: "#1e293b",
      secondaryColor: "#334155",
      accentColor: "#4b5563"
    },
    {
      id: "autumn",
      name: "Autumn",
      backgroundColor: "#fef2f2",
      textColor: "#7f1d1d",
      primaryColor: "#fecaca",
      secondaryColor: "#fca5a5",
      accentColor: "#f87171"
    },
    {
      id: "business",
      name: "Business",
      backgroundColor: "#1e293b",
      textColor: "#f1f5f9",
      primaryColor: "#334155",
      secondaryColor: "#475569",
      accentColor: "#64748b"
    },
    {
      id: "acid",
      name: "Acid",
      backgroundColor: "#f0fdf4",
      textColor: "#166534",
      primaryColor: "#dcfce7",
      secondaryColor: "#bbf7d0",
      accentColor: "#86efac"
    },
    {
      id: "lemonade",
      name: "Lemonade",
      backgroundColor: "#fff7ed",
      textColor: "#7c2d12",
      primaryColor: "#ffedd5",
      secondaryColor: "#fed7aa",
      accentColor: "#fdba74"
    },
    {
      id: "night",
      name: "Night",
      backgroundColor: "#0f172a",
      textColor: "#f1f5f9",
      primaryColor: "#1e293b",
      secondaryColor: "#334155",
      accentColor: "#4b5563"
    },
    {
      id: "coffee",
      name: "Coffee",
      backgroundColor: "#1c1917",
      textColor: "#fafaf9",
      primaryColor: "#292524",
      secondaryColor: "#3f3f46",
      accentColor: "#52525b"
    },
    {
      id: "winter",
      name: "Winter",
      backgroundColor: "#f8fafc",
      textColor: "#0f172a",
      primaryColor: "#e2e8f0",
      secondaryColor: "#cbd5e1",
      accentColor: "#94a3b8"
    },
    {
      id: "dim",
      name: "Dim",
      backgroundColor: "#1a1c1e",
      textColor: "#e4e4e7",
      primaryColor: "#2b2b2b",
      secondaryColor: "#3f3f46",
      accentColor: "#52525b"
    },
    {
      id: "nord",
      name: "Nord",
      backgroundColor: "#f8fafc",
      textColor: "#0f172a",
      primaryColor: "#e2e8f0",
      secondaryColor: "#cbd5e1",
      accentColor: "#94a3b8"
    },
    {
      id: "sunset",
      name: "Sunset",
      backgroundColor: "#f8f5e4",
      textColor: "#1c1917",
      primaryColor: "#fed7aa",
      secondaryColor: "#fed7aa",
      accentColor: "#fdba74"
    }
  ];

Path: D:\Modible\Software\pocketbase-sveltekit-starter\sk\src\routes\+layout.svelte
Contents:
<script lang="ts" context="module">
import { beforeNavigate } from "$app/navigation";
import { metadata } from "$lib/app/stores";
import { site } from "$lib/config";
import PocketBase from "pocketbase";

// Initialize PocketBase client
const pb = new PocketBase(`$(import.meta.env.VITE_APP_BASE_URL)`);
</script>

<script lang="ts">
import "../app.scss";
import Alerts from "$lib/components/Alerts.svelte";
import Nav from "$lib/components/Nav.svelte";

$: title = $metadata.title ? $metadata.title + " | " + site.name : site.name;
$: description = $metadata.description ?? site.description;
$: headline = $metadata.headline ?? $metadata.title;

// Reset metadata on navigation so that the new page inherits nothing from the old page
beforeNavigate(() => {
  $metadata = {};
});
</script>

<svelte:head>
  <title>{title}</title>
  <meta name="description" content={description} />
</svelte:head>

<div class="flex min-h-screen h-screen flex-col">
  <header>
    <Nav />
  </header>

  <main class="flex-grow">
    <div class="pt-4">
      <div class="mx-auto max-w-7xl px-4 sm:px-6 lg:px-8">
        <div class="mx-auto max-w-2xl text-center">
          {#if headline}
            <h1
              class="text-primary text-3xl font-bold tracking-tight sm:text-4xl"
            >
              {headline}
            </h1>
          {/if}
          <Alerts />
        </div>
        <slot />
      </div>
    </div>
  </main>

  <footer class="py-4">
    <div class="mx-auto max-w-7xl px-4 text-center sm:px-6 lg:px-8">
      <p class="text-base-content text-sm">      
        &copy; {new Date().getFullYear()}
        {site.name}. All rights reserved.
      </p>
    </div>
  </footer>
</div>


Path: D:\Modible\Software\pocketbase-sveltekit-starter\sk\src\routes\+layout.ts
Contents:
import type { LayoutLoad } from "./$types";
import { alerts } from "$lib/components/Alerts.svelte";

// turn off SSR - we're JAMstack here
export const ssr = false;

// Prerendering turned off. Turn it on if you know what you're doing.
export const prerender = false;

// trailing slashes make relative paths much easier
export const trailingSlash = "always";

export const load: LayoutLoad = async ({ fetch }) => {
  const response = await fetch("/_/");
  if (response.redirected) {
    alerts.add({
      message: 'Please visit <a href="/_/">/_ </a> to finalize installation of PocketBase',
      type: "error",
      html: true,
    });
  }
  return {}; // Return an empty object or an object with necessary properties
};

Path: D:\Modible\Software\pocketbase-sveltekit-starter\sk\src\routes\+page.svelte
Contents:
<script lang="ts">
import { metadata } from "$lib/app/stores";
import { fade, fly } from "svelte/transition";
import Particles from "svelte-particles";
import { loadSlim } from "tsparticles-slim";

//$metadata.title =
//  "mind.ai - Transform Your Thoughts into a Flourishing Mind Garden";
$metadata.description =
  "Discover how mind.ai empowers you to nurture, organize, and grow your ideas into something beautiful through AI-powered journaling and the Mind Gardens methodology.";

let particlesConfig = {
  particles: {
    color: {
      value: "#ffffff",
    },
    links: {
      enable: true,
      color: "#ffffff",
    },
    move: {
      enable: true,
    },
    number: {
      value: 20,
    },
    size: {
      value: 3,
    },
  },
  interactivity: {
    events: {
      onhover: {
        enable: true,
        mode: "repulse",
      },
    },
  },
};

let onParticlesLoaded = (event: CustomEvent<{ particles?: any }>) => {
  const particlesContainer = event.detail.particles;
  // you can use particlesContainer to call all the Container class
  // (from the core library) methods like play, pause, refresh, start, stop
};

let particlesInit = async (engine: any) => {
  await loadSlim(engine);
};
</script>

<svelte:head>
  <title>{$metadata.title}</title>
  <meta name="description" content={$metadata.description} />
</svelte:head>


<!-- Particles Background -->
<Particles
id="tsparticles"
options={particlesConfig}
on:particlesLoaded={onParticlesLoaded}
particlesInit={particlesInit}
/>

<!-- Hero Section -->
<div
  class="hero min-h-screen"
  style="background-image: url(img/treeBrain.png);"
>
  <div class="hero-overlay bg-opacity-60"></div>
  <div class="hero-content text-neutral-content text-center">
    <div class="max-w-md">
      <h1 class="mb-5 text-5xl font-bold">
        Transform Your Thoughts into a Flourishing Mind Garden with AI
      </h1>
      <p class="mb-5">
        Discover how mind.ai empowers you to nurture, organize, and grow your
        ideas into something beautiful.
      </p>
      <button class="btn btn-primary">Plant Your First Thought Today</button>
    </div>
  </div>
</div>

<!-- Introduction to Mind Gardens Methodology -->
<div class="bg-base-100 py-16">
  <div class="container mx-auto px-4 sm:px-6 lg:px-8">
    <div class="mb-12 text-center" transition:fade={{ duration: 500 }}>
      <h2 class="mb-4 text-4xl font-bold">Cultivate Your Mental Ecosystem</h2>
      <p class="text-xl">
        In the Mind Gardens methodology, each thought or idea is a seed that can
        grow into insights and creations. mind.ai facilitates this growth
        through AI-powered journaling, helping you nurture your mental
        ecosystem.
      </p>
    </div>
    <div class="flex justify-center">
      <img
        src="img/mindgarden.png"
        alt="Mind Garden Infographic"
        class="w-full max-w-screen-md rounded-xl object-cover shadow-xl"
        transition:fly={{ y: 20, duration: 500 }}
      />
    </div>
  </div>
</div>

<!-- Features and Benefits -->
<div class="bg-base-200 py-16" id="features">
  <div class="container mx-auto px-4 sm:px-6 lg:px-8">
    <div class="grid grid-cols-1 gap-8 md:grid-cols-2">
      <div class="flex items-center justify-center">
        <img
          src="img/cave.png"
          alt="Thought Capture Demo"
          class="h-96 w-full object-cover"
        />
      </div>
      <div transition:fly={{ x: 20, duration: 500 }}>
        <h3 class="mb-4 text-3xl font-bold">Effortless Thought Capture</h3>
        <p class="mb-4">
          Quickly jot down your ideas and watch them grow visually in your mind
          garden. The intuitive interface makes it easy to capture and organize
          your thoughts.
        </p>
        <h3 class="mb-4 text-3xl font-bold">Personalized AI Assistance</h3>
        <p class="mb-4">
          Our AI learns from your unique thought patterns and suggests prompts
          to help your ideas flourish. It's like having a personal gardener for
          your mind.
        </p>
        <h3 class="mb-4 text-3xl font-bold">Private and Secure</h3>
        <p>
          Your mind garden is your private oasis. We use state-of-the-art
          encryption to ensure your thoughts remain confidential and secure.
        </p>
      </div>
    </div>
  </div>
</div>

<!-- How It Works -->
<div class="bg-base-100 py-16" id="how-it-works">
  <div class="container mx-auto px-4 sm:px-6 lg:px-8">
    <div class="mb-12 text-center" transition:fade={{ duration: 500 }}>
      <h2 class="mb-4 text-4xl font-bold">How mind.ai Works</h2>
      <p class="text-xl">
        Our AI-powered journaling process is simple and intuitive.
      </p>
    </div>
    <div class="grid grid-cols-1 gap-8 md:grid-cols-3">
      <div class="card bg-base-200 shadow-xl">
        <figure class="px-10 pt-10">
          <img src="img/waterfall.png" alt="Capture Icon" class="rounded-xl" />
        </figure>
        <div class="card-body items-center text-center">
          <h3 class="card-title">1. Capture</h3>
          <p>Jot down your thoughts, ideas, and experiences in the app.</p>
        </div>
      </div>
      <div class="card bg-base-200 shadow-xl">
        <figure class="px-10 pt-10">
          <img src="img/thoughts.png" alt="Nurture Icon" class="rounded-xl" />
        </figure>
        <div class="card-body items-center text-center">
          <h3 class="card-title">2. Nurture</h3>
          <p>
            Our AI provides personalized prompts and insights to help your ideas
            grow.
          </p>
        </div>
      </div>
      <div class="card bg-base-200 shadow-xl">
        <figure class="px-10 pt-10">
          <img src="img/mountain.png" alt="Flourish Icon" class="rounded-xl" />
        </figure>
        <div class="card-body items-center text-center">
          <h3 class="card-title">3. Flourish</h3>
          <p>Watch your thoughts blossom into a beautiful mind garden.</p>
        </div>
      </div>
    </div>
  </div>
</div>

<!-- Pricing -->
<div class="bg-base-200 py-16" id="pricing">
  <div class="container mx-auto px-4 sm:px-6 lg:px-8">
    <div class="mb-12 text-center" transition:fade={{ duration: 500 }}>
      <h2 class="mb-4 text-4xl font-bold">Simple, Transparent Pricing</h2>
      <p class="text-xl">Choose the plan that best fits your needs.</p>
    </div>
    <div class="grid grid-cols-1 gap-8 md:grid-cols-3">
      <!-- Pricing plans go here -->
    </div>
  </div>
</div>

<!-- Testimonials -->
<div class="bg-base-100 py-16" id="testimonials">
  <div class="container mx-auto px-4 sm:px-6 lg:px-8">
    <h2 class="mb-12 text-center text-4xl font-bold">What Our Users Say</h2>
    <div class="grid grid-cols-1 gap-8 md:grid-cols-2">
      <!-- Testimonials go here -->
    </div>
  </div>
</div>

<!-- Contact -->
<div class="bg-base-200 py-16" id="contact">
  <div class="container mx-auto px-4 sm:px-6 lg:px-8">
    <div class="mb-12 text-center" transition:fade={{ duration: 500 }}>
      <h2 class="mb-4 text-4xl font-bold">Get in Touch</h2>
      <p class="text-xl">
        Have a question or want to learn more? We'd love to hear from you!
      </p>
    </div>
    <div class="flex justify-center">
      <!-- Contact form goes here -->
    </div>
  </div>
</div>

<!-- Footer -->
<footer class="footer footer-center bg-base-100 text-base-content rounded p-10">
  <!-- Footer content goes here -->
</footer>


Path: D:\Modible\Software\pocketbase-sveltekit-starter\sk\src\routes\auditlog\[coll]\[id]\+page.svelte
Contents:
<script lang="ts">
import type { PageData } from "./$types";
import Changes from "./Changes.svelte";

export let data: PageData;
</script>

<table>
  <thead>
    <th>when</th>
    <th>what</th>
    <th>who</th>
  </thead>
  <tbody>
    {#each data.logs as item}
      <tr>
        <td>{item.updated}</td>
        <td>{item.event}</td>
        <td>{item.admin || (Array.isArray(item.expand.user) ? item.expand.user[0]?.name : item.expand.user?.name) || item.user}</td>
      </tr>
      <tr>
        <!--<td colspan="3"><Changes auditlog={item} /></td>-->
      </tr>
    {:else}
      <tr>
        <td colspan="3">No records found.</td>
      </tr>
    {/each}
  </tbody>
</table>


Path: D:\Modible\Software\pocketbase-sveltekit-starter\sk\src\routes\auditlog\[coll]\[id]\+page.ts
Contents:
import { client } from "$lib/pocketbase";
import type { PageLoad } from "./$types";

export const load: PageLoad = async function ({ params: { coll, id } }) {
  const logs = await client.collection("auditlog").getFullList({
    // TODO: access control
    filter: `record="${id}" && collection="${coll}"`,
    expand: "user",
  });
  return {
    logs,
  };
};


Path: D:\Modible\Software\pocketbase-sveltekit-starter\sk\src\routes\auditlog\[coll]\[id]\Changes.svelte
Contents:
<!-- <script lang="ts">
import type { AuditlogResponse } from "$lib/pocketbase/generated-types";

export let auditlog: AuditlogResponse;
$: keys = Object.keys(auditlog.original || {});
</script>

<table>
  <tbody>
    {#each keys as key}
      <tr>
        <th>{key}</th>
        <td><pre>{auditlog.original[key]}</pre></td>
        <td><pre>{auditlog.data[key]}</pre></td>
      </tr>
    {/each}
  </tbody>
</table>

<style>
pre {
  margin: 0;
  padding: 0;
}
</style> -->


Path: D:\Modible\Software\pocketbase-sveltekit-starter\sk\src\routes\create\+page.svelte
Contents:
<script lang="ts">
import { authModel, client } from "$lib/pocketbase";
import { alertOnFailure } from "$lib/pocketbase/ui";
import { introPrompt } from "$lib/utils/prompts";
import { onMount } from "svelte";
import type {
  PostsResponse,
  PostsRecord,
} from "$lib/pocketbase/generated-types";
import { createEventDispatcher } from "svelte";
import ServiceSelector from "$lib/components/ServiceSelector.svelte";
import { availableServices } from "$lib/utils/api";
import InterpretationList from "$lib/components/InterpretationList.svelte";
import LoadingIndicator from "$lib/components/LoadingIndicator.svelte";
import PostContent from "$lib/components/PostContent.svelte";
import TagGroup from "$lib/components/TagGroup.svelte";
import { fly } from "svelte/transition";
import ImageWall from "$lib/components/ImageWall.svelte";
import { generateBlog } from "$lib/services/generateBlog";

import { serviceModelSelectionStore } from "$lib/app/stores";
    import LoginGuard from "$lib/components/LoginGuard.svelte";

const dispatch = createEventDispatcher();
let inputText = "";

let selectedService = availableServices[0]?.name;
let selectedModel = availableServices[0]?.models?.[0];
// Initialize states and reactive variables
let isLoading = {
  content: false,
  title: false,
  tags: false,
  summary: false,
  image: false,
  slug: false,
};
let formSubmitted = false;
let loadingMessage = "";
let currentStep = 0;
let chatGptInts: any[] = [];
let originalPrompt = "";
let createdPost: PostsResponse | undefined;
let isAuthenticated = false;
let post: PostsRecord = {
  title: "",
  slug: "",
  body: "",
  blogSummary: "",
  featuredImage: "",
  prompt: "",
  userid: "",
  tags: [] as string[],
};
let posts: string | any[] = [];
let isGeneratingBlog = false;
$: chatGptPrompt = "";
const engineId = "stable-diffusion-v1-6";
const apiHost = "https://api.stability.ai";
const apiKey = import.meta.env.VITE_STABILITY_API_KEY;
let responseText = "";
if (!apiKey) {
  console.error("Missing Stability API key.");
  throw new Error("Missing Stability API key.");
}

async function callAPI() {
  try {
    console.log("Calling API...");
    const response = await fetch(`/api/${selectedService.toLowerCase()}`, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ text: inputText, model: selectedModel }),
    });
    console.log("Response:", response);
    if (!response.ok) {
      throw new Error("Network response was not ok");
    }
    const data = await response.json();
    console.log("Data:", data);
    responseText = data.result;
  } catch (error) {
    responseText = "Error: " + (error as Error).message;
  }
}

onMount(async () => {
  isAuthenticated = !!$authModel;
  client.autoCancellation(false);
});

$: {
  updateProgressBar(currentStep);
}

function updateProgressBar(step: number) {
  const progressElement = document.querySelector(
    ".progress"
  ) as HTMLProgressElement;
  if (progressElement) {
    progressElement.value = step;
  }
}

async function generateGptInterpretations(promptString: string) {
  if (!$authModel?.id) {
    alert("Please log in to save your post.");
    return;
  }
  currentStep = 1;
  try {
    // Show loading screen
    isLoading.content = true;
    loadingMessage = "Generating interpretations...";
    const interpretationsResponse = (inputText = introPrompt + promptString);
    await callAPI();
    console.log("Interpretations Response:", interpretationsResponse);
    originalPrompt = promptString;
    chatGptInts = parseInterpretations(responseText);
    console.log(chatGptInts);
    formSubmitted = true;
  } catch (error) {
    console.error("Error generating interpretations:", error);
  } finally {
    // Hide loading screen
    isLoading.content = false;
  }
}

function parseInterpretations(completionText: string) {
  if (!completionText) {
    console.error("No completion text found.");
    return [];
  }

  // Hardcoded array of image URLs
  const imageUrls = {
    Optimistic: "/img/optimistic.png",
    Pessimistic: "/img/pessimistic.png",
    Realistic: "/img/realistic.png",
    Creative: "/img/creative.png",
    Analytical: "/img/analytical.png",
    "Devil's Advocate": "/img/advocate.png",
  };

  // Split the input text into lines and process each line to extract the required details
  const interpretations = completionText
    .trim()
    .split("\n")
    .filter((line) => line.trim().length > 0)
    .map((line) => {
      // Extract the title and text
      const title = line.split(":")[0].trim();
      const text = line.substring(line.indexOf(":") + 1).trim();

      // Return the new format
      return {
        title,
        text,
        imageUrl:
          imageUrls[title as keyof typeof imageUrls] || "default-image.jpg", // Fallback to a default image if the title does not match
      };
    });

  console.log(interpretations);
  return interpretations;
}

function handleInterpretationSelect(
  event: CustomEvent<{ interpretation: string }>
) {
  const interpretation = event.detail.interpretation;
  selectInterpretation(interpretation);
}

function goBack() {
  formSubmitted = false;
}

function selectInterpretation(interpretation: string) {
  chatGptPrompt = originalPrompt + " - " + interpretation;
  isGeneratingBlog = true;
  chatGptInts = [];
  isLoading.content = true;
  loadingMessage = "Generating blog...";
  generateBlog(chatGptPrompt, engineId, authModel)
    .then((generatedPost) => {
      isLoading.content = false;
      isGeneratingBlog = false;
      dispatch("blogGenerated", generatedPost);
    })
    .catch((error) => {
      alertOnFailure(error);
      isLoading.content = false;
      isGeneratingBlog = false;
    });
}
</script>

<LoginGuard>
<div>
  {#if !formSubmitted}
    {#if isLoading.content}
      <LoadingIndicator message="Loading interpretations..." />
    {:else}
      <main
        class="container mx-auto my-12 px-4 sm:px-6 lg:px-8"
        in:fly={{ y: 50, duration: 500 }}
      >
        <form
          on:submit|preventDefault={() => generateGptInterpretations(chatGptPrompt)}
          class="bg-base-200 space-y-6 rounded-lg p-6 shadow"
        >
          <ServiceSelector
            bind:selectedService={selectedService}
            bind:selectedModel={selectedModel}
          />
          <input
            type="text"
            class="input input-bordered bg-base-100 w-full"
            bind:value={chatGptPrompt}
            placeholder="Enter thoughts here"
          />
          <div class="text-right">
            <button type="submit" class="btn btn-primary">Generate</button>
          </div>
          <div class="border-accent border border-4">
            <ImageWall></ImageWall>
          </div>
        </form>
      </main>
    {/if}
  {:else if chatGptInts.length > 0 && !isGeneratingBlog}
    <main
      class="container mx-auto my-12 px-4 sm:px-6 lg:px-8"
      in:fly={{ y: 50, duration: 500 }}
    >
      <InterpretationList
        interpretations={chatGptInts}
        on:select={handleInterpretationSelect}
        on:back={goBack}
      />
    </main>
  {:else if isGeneratingBlog}
    <LoadingIndicator message={loadingMessage} />
  {:else}
    {#key chatGptPrompt}
      {#if post !== undefined}
        <div
          class="prose prose-sm sm:prose lg:prose-lg xl:prose-xl mx-auto p-4"
          in:fly={{ y: 50, duration: 500 }}
        >
          {#if post.featuredImage}
            <figure class="my-4">
              <img
                src={post.featuredImage}
                alt={post.title}
                class="mx-auto rounded-lg shadow-lg transition duration-300 ease-in-out hover:scale-105"
              />
              <figcaption class="mt-2 text-center text-sm">
                {post.title}
              </figcaption>
            </figure>
          {/if}
          <article class="prose lg:prose-lg mx-auto text-justify">
            {#if isLoading.content}
              <LoadingIndicator message="Loading content..." />
            {:else}
              <PostContent content={post.body} />
            {/if}
          </article>

          <div class="mt-8">
            <h2 class="text-2xl">Tags</h2>
            {#if isLoading.tags}
              <LoadingIndicator message="Loading tags..." />
            {:else if createdPost}
              <TagGroup post={createdPost} />
            {/if}
          </div>
        </div>
      {/if}
    {/key}
  {/if}
</div>
</LoginGuard>

Path: D:\Modible\Software\pocketbase-sveltekit-starter\sk\src\routes\explore\+page.svelte
Contents:
<script lang="ts">
import { metadata } from "$lib/app/stores";
import { goto } from "$app/navigation";
import { authModel, save } from "$lib/pocketbase";
import { alertOnFailure } from "$lib/pocketbase/ui";
import type { PageData } from "./$types";
import Markdown from "svelte-markdown";
    import LoginGuard from "$lib/components/LoginGuard.svelte";

$: test = "";
$metadata.title = "explore";
$metadata.description = "explore ai";
</script>

<LoginGuard>
Coming Soon
</LoginGuard>


Path: D:\Modible\Software\pocketbase-sveltekit-starter\sk\src\routes\hello\+page.svelte
Contents:
<script lang="ts">
    import LoginGuard from "$lib/components/LoginGuard.svelte";
import type { PageData } from "./$types";
export let data: PageData;
</script>


<LoginGuard>
<h1>Hello!</h1>
<p>Got the following API response from the backend server</p>
<pre>{JSON.stringify(data)}</pre>
</LoginGuard>

Path: D:\Modible\Software\pocketbase-sveltekit-starter\sk\src\routes\hello\+page.ts
Contents:
import type { PageLoad } from "./$types";

export const load: PageLoad = async function ({ fetch }) {
  const response = await fetch("/api/hello");
  const json = await response.json();
  return {
    ...json,
  };
};


Path: D:\Modible\Software\pocketbase-sveltekit-starter\sk\src\routes\inspire\+page.svelte
Contents:


Path: D:\Modible\Software\pocketbase-sveltekit-starter\sk\src\routes\inspire\page(old).svelte
Contents:
<script lang="ts">
import { metadata } from "$lib/app/stores";
import { goto } from "$app/navigation";
import { authModel, save, watch } from "$lib/pocketbase";
import { alertOnFailure } from "$lib/pocketbase/ui";
import type { PageData } from "./$types";
import Markdown from "svelte-markdown";
import TagGroup from "$lib/components/TagGroup.svelte";
import { client } from "$lib/pocketbase";
import { onMount, createEventDispatcher } from "svelte";
import type {
  PostsResponse,
  Collections,
} from "$lib/pocketbase/generated-types";
import { tagTreePrompt } from "$lib/utils/prompts";
import PostList from "$lib/components/PostList.svelte";
import { availableServices } from "$lib/utils/api";
import TreeView from "$lib/components/TreeView.svelte";
import { generateTagTree } from "$lib/services/generateBlog";

$: test = "";
$metadata.title = "explore";
$metadata.description = "explore ai";

const dispatch = createEventDispatcher();
let posts: PostsResponse[] = [];
let tags: string[] = [];
let selectedTags: string[] = [];
let isLoading = false;
let treeDataJson: string[] = [];

async function fetchTags() {
  try {
    const postsResponse = await client.collection("posts").getFullList({
      expand: "tags",
    });
    console.log("postsResponse", postsResponse);

    const allTags = new Set<string>();

    for (const post of postsResponse) {
      const tagsTemp: Record<string, any> | Record<string, any>[] =
        post.expand?.tags;
      if (Array.isArray(tagsTemp)) {
        for (const tag of tagsTemp) {
          if (tag && typeof tag.title === "string") {
            allTags.add(tag.title);
          }
        }
      } else if (tagsTemp && typeof tagsTemp.title === "string") {
        allTags.add(tagsTemp.title);
      }
    }

    console.log("allTags", allTags);
    tags = Array.from(allTags);
    console.log("tags", tags);
    return tags;
  } catch (error) {
    console.error("Error fetching tags:", error);
  }
}
async function sortTags(prompt: string) {
  isLoading = true;
  try {
    treeDataJson = [await generateTagTree(tags.toString(), authModel)];
console.log("treeDataJson", treeDataJson);
    // Parse the response and create the tree structure
    // Update the UI with the sorted tags
  } catch (error) {
    console.error("Error sorting tags:", error);
  }
  isLoading = false;
}

async function fetchPostsByTags() {
  try {
    const postsResponse = await client.collection("posts").getList(1, 50, {
      sort: "-updated",
      expand: "featuredImage,tags",
      filter: selectedTags.map((tag) => `tags.title="${tag}"`).join("||"),
    });
    posts = postsResponse.items.map((post) => {
      const { expand, ...rest } = post;
      return {
        ...rest,
        title: post.title as string,
        slug: post.slug as string,
        body: post.body as string,
        tags: expand.tags
          ? expand.tags.map((tag: { title: string }) => tag.title)
          : [],
        collectionName: "posts" as Collections,
      };
    });
  } catch (error) {
    console.error("Error fetching posts:", error);
  }
}

onMount(async () => {
  await fetchTags();
  await sortTags(tagTreePrompt);
});
</script>

{#if isLoading}
  <div>Loading...</div>
{:else}
  <div>
    <!-- Display the sorted tag tree -->
    <!-- Allow user to select multiple tags -->
    <TreeView treeData={treeDataJson} />
  </div>

  <div>
    <PostList posts={posts} />
  </div>
{/if}


Path: D:\Modible\Software\pocketbase-sveltekit-starter\sk\src\routes\posts\+page.svelte
Contents:
<script lang="ts">
import { metadata } from "$lib/app/stores";
import Image from "$lib/components/Image.svelte";
import { authModel, watch } from "$lib/pocketbase";
import type { PostsResponse } from "$lib/pocketbase/generated-types";
import { alertOnFailure } from "$lib/pocketbase/ui";
import { client } from "$lib/pocketbase";
import Markdown from "svelte-markdown";
import { onMount } from "svelte";
import { postsStore } from "$lib/stores/postStore";
import { fetchPosts } from "$lib/services/postService";
import { goto } from "$app/navigation";
    import LoginGuard from "$lib/components/LoginGuard.svelte";

async function getFeaturedImageUrl(post: any) {
    if (post.featuredImage) {
      const image = await client.collection("images").getOne(post.featuredImage);
      if (image && image.file) {
        return client.getFileUrl(image, image.file);
      }
    }
    return "https://via.placeholder.com/800x400.png?text=AI+Blog";
  }

async function deleteAllPosts() {
  alertOnFailure(async () => {
    const postsResponse = await client.collection("posts").getList();
    for (const post of postsResponse.items) {
      await client.collection("posts").delete(post.id);
    }
    // Optionally, refresh the posts list or navigate as needed
  });
}

$metadata.title = "";
$metadata.description = "AI powered note taking";

let posts: PostsResponse[] = [];

onMount(async () => {
  await fetchPosts();
});

postsStore.subscribe((value) => {
  posts = value;
});
</script>


<LoginGuard>
{#each posts as post (post.id)}
    <div
      class="card bg-base-300 flex w-full flex-col justify-between p-4 shadow-xl"
    >
      <div>
        <figure>
          {#await getFeaturedImageUrl(post)}
            <img
              src="https://via.placeholder.com/800x400.png?text=Loading..."
              alt="Loading..."
              class="aspect-[16/9] w-full object-cover sm:aspect-[2/1] lg:aspect-[3/2]"
            />
          {:then featuredImageUrl}
            <img
              src={featuredImageUrl}
              alt={post.title}
              class="aspect-[16/9] w-full object-cover sm:aspect-[2/1] lg:aspect-[3/2]"
            />
          {/await}
        </figure>
        <div class="m-4 max-w-xl">
          <div class="prose items-center gap-x-4">
            <!-- <time datetime="2020-03-16" class="text-accent">
              {new Date(post.updated).toLocaleDateString()}
            </time> -->
          </div>
          <div class="group relative mt-3">
            <a
              href={`/posts/${post.slug}`}
              class="prose-lg text-primary line-clamp-2 font-bold"
            >
              {post.title}
            </a>
            <div
              class="prose-sm text-base-content mt-3 line-clamp-6 text-justify"
            >
              <Markdown source={post.blogSummary || post.body} />
            </div>
          </div>
        </div>
      </div>
    </div>
  {/each}

{#if posts.length === 0}
  <div
    class="card bg-base-300 flex w-full flex-col justify-between p-4 shadow-xl"
  >
    <div>
      <div class="m-4 max-w-xl">
        <div class="prose items-center gap-x-4">
          <div class="text-accent">No posts found</div>
        </div>
      </div>
    </div>
  </div>
{/if}
</LoginGuard>

Path: D:\Modible\Software\pocketbase-sveltekit-starter\sk\src\routes\posts\+page.ts
Contents:


Path: D:\Modible\Software\pocketbase-sveltekit-starter\sk\src\routes\posts\[slug]\+page.svelte
Contents:
<script lang="ts">
  import { page } from "$app/stores";
  import { onMount } from "svelte";
  import { postsStore } from "$lib/stores/postStore";
  import { fetchPostBySlug } from "$lib/services/postService";
  import type { PostsResponse } from "$lib/pocketbase/generated-types";
  import Markdown from "svelte-markdown";
  import TagGroup from "$lib/components/TagGroup.svelte";
    import LoginGuard from "$lib/components/LoginGuard.svelte";

  let post: PostsResponse | undefined;
  $: slug = $page.params.slug;

  onMount(async () => {
    try {
      post = await fetchPostBySlug(slug);
      if (!post) {
        console.log("Post not found");
        // Handle the case when the post is not found
        // For example, you can redirect to a 404 page or show an error message
      }
    } catch (error) {
      console.error("Error fetching post:", error);
      // Handle the error case
      // For example, you can show an error message to the user
    }
  });
</script>

<LoginGuard>
{#if post}
  <div class="prose prose-sm sm:prose lg:prose-lg xl:prose-xl mx-auto p-4">
    {#if post.featuredImage}
      <figure class="my-4">
        <img src={post.featuredImage} alt={post.title} class="mx-auto rounded-lg shadow-md" />
        <figcaption class="mt-2 text-center text-sm">{post.title}</figcaption>
      </figure>
    {/if}
    <article class="prose lg:prose-lg mx-auto">
      <Markdown source={post.body} />
    </article>
    <div class="mt-8">
      <h2 class="text-2xl">Tags</h2>
      <TagGroup post={post} />
    </div>
  </div>
{:else}
  <p>Loading post...</p>
{/if}
</LoginGuard>

Path: D:\Modible\Software\pocketbase-sveltekit-starter\sk\src\routes\posts\[slug]\edit\+page.svelte
Contents:
<script lang="ts">
import { goto } from "$app/navigation";
import { page } from "$app/stores";
import { onMount } from "svelte";
import { postsStore } from "$lib/stores/postStore";
import { updatePost, fetchPostBySlug } from "$lib/services/postService";
import type { PostsResponse } from "$lib/pocketbase/generated-types";
import Markdown from "svelte-markdown";
import {
  generateTextFromChatGPT,
  generateImageFromDalle,
  ensureTagsExist,
} from "$lib/utils/api";
import {
  promptFormat,
  titlePrompt,
  tagPrompt,
  blogSummaryPrompt,
} from "$lib/utils/prompts";
    import LoginGuard from "$lib/components/LoginGuard.svelte";
let post: PostsResponse | undefined;
let tagString = "";
$: slug = $page.params.slug;
console.log("Received slug:", slug);
// Check the received slug value
onMount(async () => {
  try {
    post = await fetchPostBySlug(slug);
    if (!post) {
      console.log("Post not found");
      // Handle the case when the post is not found
      // For example, you can redirect to a 404 page or show an error message
    } else {
      tagString = post.tags ? post.tags.join(", ") : "";
    }
  } catch (error) {
    console.error("Error fetching post:", error);
    // Handle the error case // For example, you can show an error message to the user
  }
});
// Rest of the code for editing and updating the post

async function submit(e: SubmitEvent) {
  e.preventDefault();

  if (!post) return;

  const tagsArray = tagString
    .split(",")
    .map((tag) => tag.trim())
    .filter((tag) => tag.length > 0);

  const updatedPost = {
    ...post,
    title: post.title,
    slug: post.slug,
    body: post.body,
    blogSummary: post.blogSummary,
    prompt: post.prompt,
    featuredImage: post.featuredImage,
  };

  await updatePost(post.id, updatedPost);
  await updatePostsTagsRelationships(post.id, tagsArray);

  goto(`/posts/${post.slug}`);
}

async function updatePostsTagsRelationships(
  postId: string,
  tagsArray: string[]
) {
  const tagIds = await ensureTagsExist(tagsArray);
  await updatePost(postId, { tags: tagIds });
}

async function generateFromChatGPT(userPrompt: string) {
  if (userPrompt.length === 0) {
    alert("Please enter a prompt to generate from.");
    return;
  } else if (!post) return;

  post.prompt = userPrompt;

  const bodyResponse = await generateTextFromChatGPT(
    promptFormat + "This is the user's inspiration: '" + post.prompt + "'"
  );
  post.body = bodyResponse;

  const titleResponse = await generateTextFromChatGPT(
    titlePrompt + "This is the user's article: '" + bodyResponse + "'"
  );
  post.title = titleResponse.replace(/["']/g, "");
  post.slug = titleResponse
    .toLowerCase()
    .replace(/\s+/g, "-")
    .replace(/["':]/g, "")
    .substring(0, 50);

  const tagsResponse = await generateTextFromChatGPT(
    tagPrompt + "This is the blog article: '" + bodyResponse + "'"
  );
  post.tags = [tagsResponse];

  const blogSummaryResponse = await generateTextFromChatGPT(
    blogSummaryPrompt + "This is the blog article: '" + bodyResponse + "'"
  );
  post.blogSummary = blogSummaryResponse;

  const imageResponse = await generateImageFromDalle(
    titleResponse + "  " + tagsResponse
  );

  return {
    title: post.title,
    slug: post.slug,
    body: post.body,
    blogSummary: post.blogSummary,
    userid: post.userid,
    tags: post.tags,
    featuredImage: post.featuredImage,
  };
}
</script>

<LoginGuard>
<main class="container mx-auto my-12 px-4 sm:px-6 lg:px-8">
  {#if post}
    <div class="grid gap-8 lg:grid-cols-3">
      <section class="space-y-6 lg:col-span-2">
        <div class="border p-6">
          <h2 class="mb-4 text-lg font-semibold">GPT Prompt</h2>
          <div class="form-control">
            <textarea
              class="textarea h-24 w-full"
              placeholder="Enter your GPT prompt here"
              bind:value={post.prompt}
            ></textarea>
            <button
              class="btn btn-primary mt-4"
              on:click={() => generateFromChatGPT(post?.prompt ?? '')}
              >Generate</button
            >
          </div>
        </div>
        <div class="border p-6">
          <h1 class="mb-4 text-xl font-semibold">Edit Journal Entry</h1>
          <form on:submit|preventDefault={submit} class="space-y-4">
            <div class="form-control w-full">
              <label class="label" for="title">
                <span class="label-text">Title</span>
              </label>
              <input
                type="text"
                id="title"
                name="title"
                bind:value={post.title}
                class="input input-bordered w-full"
                placeholder="Your journal title"
              />
            </div>

            <div class="form-control w-full">
              <label class="label" for="slug">
                <span class="label-text">Slug</span>
              </label>
              <input
                type="text"
                id="slug"
                name="slug"
                bind:value={post.slug}
                class="input input-bordered w-full"
                placeholder="your-journal-title"
              />
            </div>

            <div class="form-control w-full">
              <label class="label" for="body">
                <span class="label-text">Body</span>
              </label>
              <article class="prose lg:prose-lg mx-auto text-justify">
                <Markdown source={post.body} />
              </article>
            </div>

            <div class="form-control w-full">
              <label class="label" for="tags">
                <span class="label-text">Tags</span>
              </label>
              <input
                type="text"
                id="tags"
                name="tags"
                bind:value={tagString}
                class="input input-bordered w-full"
                placeholder="Tags, comma separated"
              />
            </div>

            <button type="submit" class="btn btn-primary">Update</button>
          </form>
        </div>
      </section>

      <aside class="space-y-4">
        <div class="card border">
          <figure>
            <img
              src={post.featuredImage || 'https://via.placeholder.com/256x256.png?text=AI+Blog'}
              alt={post.title}
            />
          </figure>
          <div class="card-body">
            <h3 class="card-title">
              <a href="/" class="text-lg font-bold">{post.title}</a>
            </h3>
            <p>{post.blogSummary || 'No summary available.'}</p>
            <div class="card-actions justify-end">
              {#if tagString}
                {#each tagString.split(',') as tag (tag)}
                  <div class="badge badge-outline">{tag.trim()}</div>
                {/each}
              {:else}
                <div class="badge badge-outline">No Tags</div>
              {/if}
            </div>
          </div>
        </div>
      </aside>
    </div>
  {:else}
    <p>Loading post...</p>
  {/if}
</main>
</LoginGuard>

Path: D:\Modible\Software\pocketbase-sveltekit-starter\sk\src\routes\posts\[slug]\edit\+page.ts
Contents:
import { client } from "$lib/pocketbase";
import type { PostsRecord } from "$lib/pocketbase/generated-types";
import type { PageLoad } from "./$types";
import { goto } from "$app/navigation";
import { metadata } from "$lib/app/stores";
import { authModel, save } from "$lib/pocketbase";
import type { PageData } from "./$types";

export const load: PageLoad = async function ({ params }) {
  const { slug } = params;

  try {
    const { items } = await client.collection("posts").getList(undefined, undefined, {
      filter: `slug='${slug}'`,
    });

    if (items.length === 0) {
      throw new Error("Post not found");
    }

    const post: {
      userid: any;
      id: string;
      title: string;
      slug: string;
      body: string;
      tags: string[];
      blogSummary: string;
      featuredImage: string | null;
      prompt: string;
    } = items[0] as unknown as {
      userid: any;
      id: string;
      title: string;
      slug: string;
      body: string;
      tags: string[];
      blogSummary: string;
      featuredImage: string | null;
      prompt: string;
    };
    
    let featuredImageUrl = "";

    if (post.featuredImage) {
      const image = await client.collection("images").getOne(post.featuredImage);

      if (image && image.file) {
        featuredImageUrl = client.getFileUrl(image, image.file);
      }
    }

    return { post, featuredImageUrl };
  } catch (error) {
    console.error("Error fetching post:", error);
    throw error;
  }
};

Path: D:\Modible\Software\pocketbase-sveltekit-starter\sk\src\routes\posts\[slug]\inspire\+page.svelte
Contents:
<script lang="ts">
import type { PostsResponse } from "$lib/pocketbase/generated-types";
import { onMount } from "svelte";
import { page } from "$app/stores";
import { metadata } from "$lib/app/stores";
import Delete from "$lib/components/Delete.svelte";
import { authModel, client, save } from "$lib/pocketbase";
import type { PageData } from "./$types";
import Markdown from "svelte-markdown";
import { base } from "$app/paths";
import TagGroup from "$lib/components/TagGroup.svelte";
import { serviceModelSelectionStore } from "$lib/app/stores";
import ServiceSelector from "$lib/components/ServiceSelector.svelte";
import { availableServices } from "$lib/utils/api";
import { generateBlog, generateBlogResponse } from "$lib/services/generateBlog";
import type { ServiceModelSelection } from "$lib/services/generateBlog";
import { postsStore } from "$lib/stores/postStore";
import { fetchPostBySlug } from "$lib/services/postService";
export let featuredImageUrl: string = "";
let selectedService = availableServices[0].name;
let selectedModel = availableServices[0].models[0];
let post: PostsResponse | undefined;
let selectedBullets: string[] = [];
let processedBody = "";
$: slug = $page.params.slug;
// Check the received slug value
onMount(async () => {
  try {
    post = await fetchPostBySlug(slug);
    console.log("Received slug:", slug);
    if (!post) {
      console.log("Post not found");
      // Handle the case when the post is not found
      // For example, you can redirect to a 404 page or show an error message
    }
  } catch (error) {
    console.error("Error fetching post:", error);
    // Handle the error case
    // For example, you can show an error message to the user
  }
});

const getSeedPrompt = () => {
  let seedPrompt = selectedBullets.join("/n ");
  return seedPrompt;
};

function handleServiceChange(event: CustomEvent<string>) {
  selectedService = event.detail;
  serviceModelSelectionStore.update((store) => ({
    ...store,
    selectedService: selectedService,
  }));
}

function handleModelChange(event: CustomEvent<string>) {
  selectedModel = event.detail;
  serviceModelSelectionStore.update((store) => ({
    ...store,
    selectedModel: selectedModel,
  }));
}

function toggleBullet(bullet: string) {
  if (selectedBullets.includes(bullet)) {
    selectedBullets = selectedBullets.filter((b) => b !== bullet);
  } else {
    selectedBullets = [...selectedBullets, bullet];
  }
}

function parseBulletPoints(
  text: string
): { heading: string; bullets: string[] }[] {
  const sections: { heading: string; bullets: string[] }[] = [];
  const lines = text.split("\n");

  let currentHeading = "";
  let currentBullets: string[] = [];

  for (const line of lines) {
    if (line.startsWith("#")) {
      if (currentHeading && currentBullets.length > 0) {
        sections.push({ heading: currentHeading, bullets: currentBullets });
      }
      currentHeading = line.replace(/^#+\s*/, "").trim();
      currentBullets = [];
    } else if (line.match(/^\s*[-*]\s+(.+)/)) {
      const bullet = line.replace(/^\s*[-*]\s+/, "").trim();
      currentBullets.push(bullet);
    }
  }

  if (currentHeading && currentBullets.length > 0) {
    sections.push({ heading: currentHeading, bullets: currentBullets });
  }

  return sections;
}

$: if (post) {
  processedBody = post.body.replace(/^(#+)\s+(.*)/gm, (match, p1, p2) => {
    const level = p1.length;
    const fontSize = `text-${4 - level + 1}xl`;
    const classes = `${fontSize} font-bold mb-4`;
    return `<h${level} class="${classes}">${p2}</h${level}>`;
  });
}
</script>

<LoginGuard>
<main class="prose prose-sm sm:prose lg:prose-lg xl:prose-xl mx-auto p-4">
  <ServiceSelector
    bind:selectedService={selectedService}
    bind:selectedModel={selectedModel}
    on:serviceChange={handleServiceChange}
    on:modelChange={handleModelChange}
  />
  {#if post}
    <figure>
      <!-- PostCard.svelte -->
      {#if post.expand?.featuredImage}
        {@const imageRecord = post.expand.featuredImage}
        {@const imageUrl = imageRecord && imageRecord.file ? client.getFileUrl(imageRecord, imageRecord.file) : ''}
        <img
          src={imageUrl}
          alt={post.title}
          class="aspect-[16/9] w-full object-cover sm:aspect-[2/1] lg:aspect-[3/2]"
        />
      {:else}
        <img
          src="https://via.placeholder.com/800x400.png?text=AI+Blog"
          alt="Placeholder"
          class="aspect-[16/9] w-full object-cover sm:aspect-[2/1] lg:aspect-[3/2]"
        />
      {/if}
    </figure>

    <h1 class="mb-4 text-4xl font-bold">{post.title}</h1>

    <section class="mt-8">
      <button
        class="btn btn-block mt-2 text-center"
        on:click={() => selectedBullets = []}
      >
        Clear Selection
      </button>
      <div class="mt-8">
        {#each parseBulletPoints(post.body) as section}
          <h2 class="text-2xl font-bold">{section.heading}</h2>
          {#if section.bullets.length > 0}
            <ul class="list-disc pl-6">
              {#each section.bullets as bullet (bullet)}
                <li class="mb-2">
                  <button
                    class={`bullet-point hover:bg-primary flex cursor-pointer items-baseline px-4 py-2 text-left transition duration-200 ease-in-out ${selectedBullets.includes(bullet) ? 'bg-primary text-primary-content' : ''}`}
                    on:click={() => toggleBullet(bullet)}
                    aria-label={`Bullet point: ${bullet}`}
                    type="button"
                  >
                    {bullet}
                  </button>
                </li>
              {/each}
            </ul>
          {:else}
            <p>No key takeaways found in this section.</p>
          {/if}
        {/each}
      </div>
    </section>
    <div class="align-right mt-8">
      <button
        class="btn btn-block mt-2 text-center"
        on:click={() => {
        if ($serviceModelSelectionStore && post) {
          generateBlogResponse(getSeedPrompt(), post.id, authModel);
        } else {
          console.error('Service model selection is not set');
        }
      }}
      >
        Generate Inspiration
      </button>
    </div>

    <div class="">
      <h2 class="w-screen text-2xl">Tags</h2>
      <TagGroup post={post} />
    </div>

    <div class="mt-8 text-center">
      <a href={`${base}/auditlog/posts/${post.id}`} class="btn btn-primary">
        Audit Log
      </a>
    </div>
  {/if}
</main>

<style>
</style>
</LoginGaurd>

Path: D:\Modible\Software\pocketbase-sveltekit-starter\sk\src\routes\reflect\+page.svelte
Contents:
<script lang="ts">
import { metadata } from "$lib/app/stores";
import { goto } from "$app/navigation";
import { authModel, save } from "$lib/pocketbase";
import { alertOnFailure } from "$lib/pocketbase/ui";
import type { PageData } from "./$types";
import Markdown from "svelte-markdown";
    import LoginGuard from "$lib/components/LoginGuard.svelte";

$: test = "";
$metadata.title = "reflect";
$metadata.description = "reflect ai";
</script>


<LoginGuard>
Coming Soon
</LoginGuard>

Path: D:\Modible\Software\pocketbase-sveltekit-starter\sk\src\routes\remember\+page.svelte
Contents:
<script lang="ts">
import { postsStore, fetchPosts } from "$lib/services/postService";
import type { PostsResponse } from "$lib/pocketbase/generated-types";
import { metadata } from "$lib/app/stores";
import PostList from "$lib/components/PostList.svelte";
import { onMount } from "svelte";
    import LoginGuard from "$lib/components/LoginGuard.svelte";
let posts: PostsResponse[] = [];
postsStore.subscribe((value) => {
  posts = value.posts;
});
$metadata.title = "";
$metadata.description = "AI powered note taking";
// Fetch posts when the component is mounted
onMount(async () => {
  await fetchPosts();
});
</script>


<LoginGuard>
<div>
  <div class="mx-auto max-w-7xl px-6 lg:px-8">
    {#if Array.isArray(posts)}
      <div
        class="grid grid-cols-1 gap-x-2 gap-y-20 overflow-y-auto lg:grid-cols-3"
        style="max-height: calc(100vh - 220px);"
      >
        <PostList posts={posts} />
      </div>
    {:else}
      <p>Error: Posts data is not available.</p>
    {/if}
  </div>
</div>
</LoginGuard>


Path: D:\Modible\Software\pocketbase-sveltekit-starter\sk\src\routes\subposts\[slug]\+page.svelte
Contents:


Path: D:\Modible\Software\pocketbase-sveltekit-starter\sk\src\routes\tags\[tag]\+page.svelte
Contents:
<script lang="ts">
  import type { PostsResponse, TagsResponse } from "$lib/pocketbase/generated-types";
  import { onMount } from "svelte";
  import { page } from "$app/stores";
  import { client } from "$lib/pocketbase";
  import PostList from "$lib/components/PostList.svelte";
    import LoginGuard from "$lib/components/LoginGuard.svelte";

  let posts: PostsResponse[] = [];
  let tag: TagsResponse | undefined;

  onMount(async () => {
    const { tag: tagTitle } = $page.params;
    try {
      // Fetch the tag record by title
      const tagResponse = await client.collection("tags").getFirstListItem(`title = '${tagTitle}'`);
      tag = tagResponse as unknown as TagsResponse;

      if (tag) {
        // Fetch the posts related to the tag
        const response = await client.collection("posts").getList(1, 50, {
          filter: `tags ~ '${tag.id}'`,
          expand: "featuredImage,tags",
        });
        posts = response.items as unknown as PostsResponse[];
        console.log("posts", posts);
      }
    } catch (error) {
      console.error("Error fetching posts:", error);
    }
  });
</script>


<LoginGuard>
<div class="container mx-auto px-4">
  {#if tag}
    <h1 class="text-4xl font-bold mb-8">Blogs tagged with "{tag.title}"</h1>

    {#if posts.length > 0}
      <PostList {posts} />
    {:else}
      <p>No blogs found with the tag "{tag.title}".</p>
    {/if}
  {:else}
    <p>Tag not found.</p>
  {/if}
</div>
</LoginGuard>

Path: D:\Modible\Software\pocketbase-sveltekit-starter\sk\tests\smoke.test.ts
Contents:
import { test, expect, type Page } from "@playwright/test";
import playwright from "playwright";

const ts = Date.now();
const email = ts + "@test.com";
const password = "0123456789";

async function doLogin(page: Page) {
  await page.locator("summary").click();
  await page.getByPlaceholder("email").fill(email);
  await page.getByPlaceholder("password").fill(password);
  await page.getByRole("button", { name: "Login" }).click();
  const logout = await page.getByRole("button", { name: "Logout" });
  expect(logout).toBeDefined();
  const name = await page.locator("button>samp").innerText();
  expect(name, email);
}

test("posts logged out", async ({ page }) => {
  await page.goto("/posts");
  const heading = await page.getByRole("heading", { name: "Recent Posts" });
  expect(heading).toBeDefined();
  const p = await page.getByText("Please login to create new posts.");
  expect(p).toBeDefined();
});

test("register", async ({ page }) => {
  await page.goto("/posts");
  await page.locator("summary").click();
  await page.getByPlaceholder("email").fill(email);
  await page.getByPlaceholder("password").fill(password);
  await page.getByLabel("Register").check();
  await page.getByPlaceholder("confirm password").fill("0123456789");
  await page.getByRole("button", { name: "Login" }).click();
  const name = await page.locator("button>samp").innerText();
  expect(name, email);
});

test("login", async ({ page }) => {
  await page.goto("/posts");
  await doLogin(page);
  const name = await page.locator("button>samp").innerText();
  expect(name, email);
});

test("posts logged in", async ({ page }) => {
  await page.goto("/posts");
  await doLogin(page);
  const heading = await page.getByRole("heading", { name: "Recent Posts" });
  expect(heading).toBeDefined();
  const link = await page.getByRole("link", { name: "Create New" });
  expect(link).toBeDefined();
});

const title = "post at " + ts;
const slug = "post-" + ts;

test("create post", async ({ page }) => {
  // second browser to test realtime subscriptions
  const b2 = (await (await playwright.chromium.launch()).newPage()) as Page;
  await b2.goto("/posts");
  await doLogin(b2);

  await page.goto("/posts");
  await doLogin(page);
  await page.getByRole("link", { name: "Create New" }).click();
  await page.getByPlaceholder("title").click();
  const ts = Date.now();
  await page.getByPlaceholder("title").fill(title);
  await page.getByPlaceholder("slug").fill(slug);
  await page.getByPlaceholder("body").fill("line 1\nline 2");
  // await page.locator('input[type="file"]').setInputFiles("posts-1.png");
  await page.locator('input[type="file"]').setInputFiles("README.md");
  await page.getByRole("button", { name: "Submit" }).click();
  await expect(page).toHaveURL(/\/posts\/$/);
  await page.getByRole("link", { name: title }).click();
  await expect(page).toHaveURL(/\/posts\/.+\/$/);
  const heading = await page.getByRole("heading", { name: title });
  expect(heading).toBeDefined();
  // check realtime activity in the second browser
  const link = await b2.getByRole("link", { name: title });
  expect(link).toBeDefined();
});

test("delete post", async ({ page }) => {
  await page.goto(`/posts/${slug}/#delete`);
  await doLogin(page);
  await page.getByRole("button", { name: "No - Cancel" }).click();
  await expect(page).toHaveURL(/\/posts\/$/);
  await page.goto(`/posts/${slug}/#delete`);
  await page.getByRole("button", { name: "Yes - Proceed" }).click();
  await expect(page).toHaveURL(/\/posts\/$/);
});




Project Tree View:
├── 
│   ├── .dockerignore
│   ├── click on a bullet point and generat.txt
│   ├── Dockerfile
│   ├── fly.toml
│   ├── LICENSE.md
│   ├── Procfile
│   ├── README.md
│   ├── runit.bat
│   ├── textGen.py
│   └── Things to do
├── .vscode
│   └── settings.json
├── pb
│   ├── .dockerignore
│   ├── Dockerfile
│   ├── entrypoint.sh
│   ├── example-hook-script.sh
│   ├── fly.toml
│   ├── main.go
│   ├── modd.conf
│   ├── README.md
│   ├── auditlog
│   │   └── auditlog.go
│   ├── data
│   │   └── email_templates
│   │       └── post.html
│   ├── hooks
│   │   ├── email.go
│   │   └── hooks.go
│   ├── pb_hooks
│   │   └── main.pb.ts
│   └── pb_public
│       └── images
└── sk
    ├── .prettierignore
    ├── .prettierrc
    ├── playwright.config.ts
    ├── postcss.config.cjs
    ├── README.md
    ├── svelte.config.js
    ├── tailwind.config.cjs
    ├── tsconfig.json
    ├── vite.config.ts
    ├── src
    │   ├── app.d.ts
    │   ├── app.html
    │   ├── app.pcss
    │   ├── app.scss
    │   ├── lib
    │   │   ├── config.ts
    │   │   ├── app
    │   │   │   └── stores.ts
    │   │   ├── components
    │   │   │   ├── Alerts.svelte
    │   │   │   ├── DateShow.svelte
    │   │   │   ├── Delete.svelte
    │   │   │   ├── Dialog.svelte
    │   │   │   ├── FileInput.svelte
    │   │   │   ├── Image.svelte
    │   │   │   ├── ImageWall.svelte
    │   │   │   ├── InterpretationList.svelte
    │   │   │   ├── LoadingIndicator.svelte
    │   │   │   ├── LoginBadge.svelte
    │   │   │   ├── LoginForm.svelte
    │   │   │   ├── LoginGuard.svelte
    │   │   │   ├── Nav.svelte
    │   │   │   ├── PostCard.svelte
    │   │   │   ├── PostContent.svelte
    │   │   │   ├── PostList.svelte
    │   │   │   ├── ServiceForm.svelte
    │   │   │   ├── ServiceSelector.svelte
    │   │   │   ├── Spinner.svelte
    │   │   │   ├── Tab.svelte
    │   │   │   ├── TabContent.svelte
    │   │   │   ├── TabGroup.svelte
    │   │   │   ├── TagEditor.svelte
    │   │   │   ├── TagGroup.svelte
    │   │   │   ├── ThemeSwitch.svelte
    │   │   │   └── TreeView.svelte
    │   │   ├── pocketbase
    │   │   │   ├── generated-types.ts
    │   │   │   ├── ImgModal.svelte
    │   │   │   ├── index.ts
    │   │   │   ├── Paginator.svelte
    │   │   │   ├── pocketbase-types.ts
    │   │   │   └── ui.ts
    │   │   ├── services
    │   │   │   ├── generateBlog.ts
    │   │   │   └── postService.ts
    │   │   ├── stores
    │   │   │   └── postStore.ts
    │   │   └── utils
    │   │       ├── api.ts
    │   │       ├── prompts.ts
    │   │       └── themes.ts
    │   └── routes
    │       ├── +layout.svelte
    │       ├── +layout.ts
    │       ├── +page.svelte
    │       ├── auditlog
    │       │   └── [coll]
    │       │       └── [id]
    │       │           ├── +page.svelte
    │       │           ├── +page.ts
    │       │           └── Changes.svelte
    │       ├── create
    │       │   └── +page.svelte
    │       ├── explore
    │       │   └── +page.svelte
    │       ├── hello
    │       │   ├── +page.svelte
    │       │   └── +page.ts
    │       ├── inspire
    │       │   ├── +page.svelte
    │       │   └── page(old).svelte
    │       ├── posts
    │       │   ├── +page.svelte
    │       │   ├── +page.ts
    │       │   └── [slug]
    │       │       ├── +page.svelte
    │       │       ├── edit
    │       │       │   ├── +page.svelte
    │       │       │   └── +page.ts
    │       │       └── inspire
    │       │           └── +page.svelte
    │       ├── reflect
    │       │   └── +page.svelte
    │       ├── remember
    │       │   └── +page.svelte
    │       ├── subposts
    │       │   └── [slug]
    │       │       └── +page.svelte
    │       └── tags
    │           └── [tag]
    │               └── +page.svelte
    ├── static
    │   ├── favicon.ico
    │   └── img
    └── tests
        └── smoke.test.ts
